<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Problems zoo · ProblemReductions.jl</title><meta name="title" content="Problems zoo · ProblemReductions.jl"/><meta property="og:title" content="Problems zoo · ProblemReductions.jl"/><meta property="twitter:title" content="Problems zoo · ProblemReductions.jl"/><meta name="description" content="Documentation for ProblemReductions.jl."/><meta property="og:description" content="Documentation for ProblemReductions.jl."/><meta property="twitter:description" content="Documentation for ProblemReductions.jl."/><meta property="og:url" content="https://GiggleLiu.github.io/ProblemReductions.jl/models/"/><meta property="twitter:url" content="https://GiggleLiu.github.io/ProblemReductions.jl/models/"/><link rel="canonical" href="https://GiggleLiu.github.io/ProblemReductions.jl/models/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/indigo.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ProblemReductions.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../generated/Ising/">Solving Factoring problem with Ising machine</a></li><li><a class="tocitem" href="../rules/spinglass_sat/">CircuitSAT -&gt; SpinGlass</a></li><li><a class="tocitem" href="../rules/independentset_setpacking/">Independent Set -&gt; Set Packing</a></li></ul></li><li class="is-active"><a class="tocitem" href>Problems zoo</a></li><li><a class="tocitem" href="../ref/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Problems zoo</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Problems zoo</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/GiggleLiu/ProblemReductions.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/GiggleLiu/ProblemReductions.jl/blob/main/docs/src/models.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Problems-zoo"><a class="docs-heading-anchor" href="#Problems-zoo">Problems zoo</a><a id="Problems-zoo-1"></a><a class="docs-heading-anchor-permalink" href="#Problems-zoo" title="Permalink"></a></h1><ul><li><a href="#ProblemReductions.AbstractProblem"><code>ProblemReductions.AbstractProblem</code></a></li><li><a href="#ProblemReductions.AbstractSatisfiabilityProblem"><code>ProblemReductions.AbstractSatisfiabilityProblem</code></a></li><li><a href="#ProblemReductions.CircuitSAT"><code>ProblemReductions.CircuitSAT</code></a></li><li><a href="#ProblemReductions.Coloring"><code>ProblemReductions.Coloring</code></a></li><li><a href="#ProblemReductions.ConstraintSatisfactionProblem"><code>ProblemReductions.ConstraintSatisfactionProblem</code></a></li><li><a href="#ProblemReductions.DominatingSet"><code>ProblemReductions.DominatingSet</code></a></li><li><a href="#ProblemReductions.Factoring"><code>ProblemReductions.Factoring</code></a></li><li><a href="#ProblemReductions.IndependentSet"><code>ProblemReductions.IndependentSet</code></a></li><li><a href="#ProblemReductions.KSatisfiability"><code>ProblemReductions.KSatisfiability</code></a></li><li><a href="#ProblemReductions.Matching"><code>ProblemReductions.Matching</code></a></li><li><a href="#ProblemReductions.MaxCut"><code>ProblemReductions.MaxCut</code></a></li><li><a href="#ProblemReductions.MaximalIS"><code>ProblemReductions.MaximalIS</code></a></li><li><a href="#ProblemReductions.PaintShop"><code>ProblemReductions.PaintShop</code></a></li><li><a href="#ProblemReductions.QUBO"><code>ProblemReductions.QUBO</code></a></li><li><a href="#ProblemReductions.Satisfiability"><code>ProblemReductions.Satisfiability</code></a></li><li><a href="#ProblemReductions.SetCovering"><code>ProblemReductions.SetCovering</code></a></li><li><a href="#ProblemReductions.SetPacking"><code>ProblemReductions.SetPacking</code></a></li><li><a href="#ProblemReductions.SpinGlass"><code>ProblemReductions.SpinGlass</code></a></li><li><a href="#ProblemReductions.VertexCovering"><code>ProblemReductions.VertexCovering</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ProblemReductions.AbstractProblem" href="#ProblemReductions.AbstractProblem"><code>ProblemReductions.AbstractProblem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractProblem</code></pre><p>The abstract base type of computational problems.</p><p><strong>Required interfaces</strong></p><ul><li><a href="../ref/#ProblemReductions.variables-Tuple{AbstractProblem}"><code>variables</code></a>, the degrees of freedoms in the computational problem.</li><li><a href="../ref/#ProblemReductions.flavors-Tuple{GT} where GT&lt;:AbstractProblem"><code>flavors</code></a>, the flavors (domain) of a degree of freedom.</li><li><a href="../ref/#ProblemReductions.solution_size"><code>solution_size</code></a>, the size (the lower the better) of the input configuration.</li><li><a href="../ref/#ProblemReductions.problem_size"><code>problem_size</code></a>, the size of the computational problem. e.g. for a graph, it could be <code>(n_vertices=?, n_edges=?)</code>.</li></ul><p><strong>Optional interfaces</strong></p><ul><li><a href="../ref/#ProblemReductions.num_variables"><code>num_variables</code></a>, the number of variables in the computational problem.</li><li><a href="../ref/#ProblemReductions.num_flavors-Tuple{GT} where GT&lt;:AbstractProblem"><code>num_flavors</code></a>, the number of flavors (domain) of a degree of freedom.</li><li><a href="../ref/#ProblemReductions.findbest"><code>findbest</code></a>, find the best configurations of the input problem.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/ProblemReductions.jl/blob/180579b61116b3a92c52051e9a87c7619fa4c902/src/models/models.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ProblemReductions.AbstractSatisfiabilityProblem" href="#ProblemReductions.AbstractSatisfiabilityProblem"><code>ProblemReductions.AbstractSatisfiabilityProblem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractSatisfiabilityProblem{S, T} &lt;: ConstraintSatisfactionProblem{T}</code></pre><p>The abstract type for <a href="#ProblemReductions.Satisfiability"><code>Satisfiability</code></a> and <a href="#ProblemReductions.KSatisfiability"><code>KSatisfiability</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/ProblemReductions.jl/blob/180579b61116b3a92c52051e9a87c7619fa4c902/src/models/Satisfiability.jl#L100-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ProblemReductions.CircuitSAT" href="#ProblemReductions.CircuitSAT"><code>ProblemReductions.CircuitSAT</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct CircuitSAT{T, WT&lt;:AbstractArray{T, 1}} &lt;: ConstraintSatisfactionProblem{T}</code></pre><p>Circuit satisfiability problem, where the goal is to find an assignment that satisfies the circuit.</p><p><strong>Fields</strong></p><ul><li><code>circuit::Circuit</code>: The circuit expression in simplified form.</li><li><code>symbols::Vector{Symbol}</code>: The variables in the circuit.</li></ul><p><strong>Example</strong></p><p>A circuit can be defined with the @circuit macro as follows:</p><pre><code class="language-julia-repl hljs">julia&gt; using ProblemReductions

julia&gt; circuit = @circuit begin
           c = x ∧ y
           d = x ∨ (c ∧ ¬z)
       end
Circuit:
| c = ∧(x, y)
| d = ∨(x, ∧(c, ¬(z)))

julia&gt; sat = CircuitSAT(circuit)
CircuitSAT:
| c = ∧(x, y)
| ##var#354 = ¬(z)
| ##var#353 = ∧(c, ##var#354)
| d = ∨(x, ##var#353)
Symbols: [:c, :x, :y, Symbol(&quot;##var#354&quot;), :z, Symbol(&quot;##var#353&quot;), :d]

julia&gt; sat.symbols
7-element Vector{Symbol}:
 :c
 :x
 :y
 Symbol(&quot;##var#354&quot;)
 :z
 Symbol(&quot;##var#353&quot;)
 :d

julia&gt; flavors(sat)
(0, 1)

julia&gt; solution_size(sat, [true, false, true, true, false, false, true])
SolutionSize{Int64}(3, true)

julia&gt; findbest(sat, BruteForce())
8-element Vector{Vector{Int64}}:
 [0, 0, 0, 1, 0, 0, 0]
 [0, 0, 1, 1, 0, 0, 0]
 [0, 0, 0, 0, 1, 0, 0]
 [0, 0, 1, 0, 1, 0, 0]
 [0, 1, 0, 1, 0, 0, 1]
 [0, 1, 0, 0, 1, 0, 1]
 [1, 1, 1, 0, 1, 0, 1]
 [1, 1, 1, 1, 0, 1, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/ProblemReductions.jl/blob/180579b61116b3a92c52051e9a87c7619fa4c902/src/models/Circuit.jl#L190">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ProblemReductions.Coloring" href="#ProblemReductions.Coloring"><code>ProblemReductions.Coloring</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Coloring{K, T, WT&lt;:AbstractArray{T, 1}} &lt;: ConstraintSatisfactionProblem{T}</code></pre><pre><code class="nohighlight hljs">Coloring{K}(graph; weights=UnitWeight(nv(graph)))</code></pre><p>The Vertex Coloring (Coloring) problem is defined on a simple graph. Given k kinds of colors, we need to determine whether we can color all vertices on the graph such that no two adjacent vertices share the same color.</p><p><strong>Fields</strong></p><ul><li><code>graph</code> is the problem graph.</li><li><code>weights</code> are associated with the edges of the <code>graph</code>, default to <code>UnitWeight(ne(graph))</code>.</li></ul><p><strong>Example</strong></p><p>To initialize a Coloring problem, we need to first define a graph and decide the number of colors.</p><pre><code class="language-julia-repl hljs">julia&gt; using ProblemReductions, Graphs

julia&gt; g = smallgraph(:petersen) # define a simple graph, petersen as example
{10, 15} undirected simple Int64 graph

julia&gt; coloring = Coloring{3}(g)  # 3 colors
Coloring{3, Int64, UnitWeight}(SimpleGraph{Int64}(15, [[2, 5, 6], [1, 3, 7], [2, 4, 8], [3, 5, 9], [1, 4, 10], [1, 8, 9], [2, 9, 10], [3, 6, 10], [4, 6, 7], [5, 7, 8]]), [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])

julia&gt; variables(coloring)
1:10

julia&gt; flavors(coloring)
(0, 1, 2)

julia&gt; is_vertex_coloring(coloring.graph,[1,2,3,1,3,2,1,2,3,1]) #random assignment
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/ProblemReductions.jl/blob/180579b61116b3a92c52051e9a87c7619fa4c902/src/models/Coloring.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ProblemReductions.ConstraintSatisfactionProblem" href="#ProblemReductions.ConstraintSatisfactionProblem"><code>ProblemReductions.ConstraintSatisfactionProblem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ConstraintSatisfactionProblem{T} &lt;: AbstractProblem</code></pre><p>The abstract base type of constraint satisfaction problems. <code>T</code> is the type of the local size of the constraints.</p><p><strong>Required interfaces</strong></p><ul><li><p><a href="../ref/#ProblemReductions.hard_constraints"><code>hard_constraints</code></a>, the specification of the hard constraints. Once the hard constraints are violated, the size goes to infinity.</p></li><li><p><a href="../ref/#ProblemReductions.is_satisfied"><code>is_satisfied</code></a>, check if the hard constraints are satisfied.</p></li><li><p><a href="../ref/#ProblemReductions.local_solution_spec"><code>local_solution_spec</code></a>, the specification of the size terms as soft constraints, which is associated with weights.</p></li><li><p><a href="../ref/#ProblemReductions.weights"><code>weights</code></a>: The weights of the soft constraints.</p></li><li><p><a href="../ref/#ProblemReductions.set_weights"><code>set_weights</code></a>: Change the weights for the <code>problem</code> and return a new problem instance.</p></li><li><p><a href="../ref/#ProblemReductions.solution_size"><code>solution_size</code></a>, the size of the problem given a configuration.</p></li><li><p><a href="../ref/#ProblemReductions.energy_mode-Tuple{AbstractProblem}"><code>energy_mode</code></a>, the definition of the energy function, which can be <code>LargerSizeIsBetter</code> or <code>SmallerSizeIsBetter</code>.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/ProblemReductions.jl/blob/180579b61116b3a92c52051e9a87c7619fa4c902/src/models/models.jl#L35-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ProblemReductions.DominatingSet" href="#ProblemReductions.DominatingSet"><code>ProblemReductions.DominatingSet</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct DominatingSet{GT&lt;:Graphs.AbstractGraph, T, WT&lt;:AbstractArray{T, 1}} &lt;: ConstraintSatisfactionProblem{T}</code></pre><pre><code class="nohighlight hljs">DominatingSet(graph::AbstractGraph, weights::AbstractVector=UnitWeight(ne(graph))) -&gt; DominatingSet</code></pre><p>Dominaing Set is a subset of vertices in a undirected graph such that all the vertices in the set are either in the dominating set or in its first-order neighborhood. The DominatingSet problem is to find the dominating set with minimum number of vertices.</p><p><strong>Fields</strong></p><ul><li><code>graph</code> is the problem graph.</li><li><code>weights::AbstractVector</code>: Weights associated with the vertices of the <code>graph</code>. Defaults to <code>UnitWeight(nv(graph))</code>.</li></ul><p><strong>Example</strong></p><p>In the following example, we define a dominating set problem on a path graph with five vertices. To define a <code>DominatingSet</code> problem, we need to specify the graph and possibily the weights associated with vertices. The weights are set as unit by default in the current version and might be generalized to arbitrary positive weights in the following development.</p><pre><code class="language-julia-repl hljs">julia&gt; using ProblemReductions, Graphs

julia&gt; graph = path_graph(5)
{5, 4} undirected simple Int64 graph

julia&gt; DS = DominatingSet(graph)
DominatingSet{SimpleGraph{Int64}, Int64, UnitWeight}(SimpleGraph{Int64}(4, [[2], [1, 3], [2, 4], [3, 5], [4]]), [1, 1, 1, 1, 1])

julia&gt; variables(DS)  # degrees of freedom
1:5

julia&gt; flavors(DS)  # flavors of the vertices
(0, 1)

julia&gt; solution_size(DS, [0, 1, 0, 1, 0]) # Positive sample: (size) of a dominating set
SolutionSize{Int64}(2, true)

julia&gt; solution_size(DS, [0, 1, 1, 0, 0]) # Negative sample: number of vertices
SolutionSize{Int64}(2, false)

julia&gt; findbest(DS, BruteForce())  # solve the problem with brute force
3-element Vector{Vector{Int64}}:
 [1, 0, 0, 1, 0]
 [0, 1, 0, 1, 0]
 [0, 1, 0, 0, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/ProblemReductions.jl/blob/180579b61116b3a92c52051e9a87c7619fa4c902/src/models/DominatingSet.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ProblemReductions.Factoring" href="#ProblemReductions.Factoring"><code>ProblemReductions.Factoring</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Factoring &lt;: AbstractProblem</code></pre><p>Prime Factorization (Factoring) is to decompose a number <span>$m$</span> into its prime factors <span>$p$</span> and <span>$q$</span>, denoted as <span>$m = p × q$</span>.</p><p><strong>Fields</strong></p><ul><li><code>m::Int</code>: number of bits for the first number</li><li><code>n::Int</code>: number of bits for the second number</li><li><code>input::Int</code>: the number to factorize</li></ul><p><strong>Example</strong></p><p>In the following example, the two 2 is the factors&#39; bit size and 6 is the number to be factored. 6 is 110 in binary so its factors should be 2-bits number.</p><pre><code class="language-julia-repl hljs">julia&gt; using ProblemReductions

julia&gt; factoring = Factoring(2,2,6)
Factoring(2, 2, 6)

julia&gt; variables(factoring) # return the sum of factors&#39; bit size
1:4

julia&gt; flavors(factoring)
(0, 1)

julia&gt; solution_size(factoring,[0,1,1,1]) # 01 -&gt; 2, 11 -&gt; 3
SolutionSize{Int64}(0, true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/ProblemReductions.jl/blob/180579b61116b3a92c52051e9a87c7619fa4c902/src/models/Factoring.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ProblemReductions.IndependentSet" href="#ProblemReductions.IndependentSet"><code>ProblemReductions.IndependentSet</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct IndependentSet{GT&lt;:Graphs.AbstractGraph, T, WT&lt;:AbstractArray{T, 1}} &lt;: ConstraintSatisfactionProblem{T}</code></pre><pre><code class="nohighlight hljs">IndependentSet(graph::AbstractGraph, weights::AbstractVector=UnitWeight(nv(graph))) -&gt; IndependentSet</code></pre><p>Independent Set is a subset of vertices in a undirected graph such that all the vertices in the set are not connected by edges (or called not adjacent). The maximum IndependentSet problem is to find the independent set with maximum number of vertices, which is a NP-complete problem. Let <span>$G=(V, E)$</span> be a graph, and <span>$w_v$</span> be the weight of vertex <span>$v$</span>. The energy based model of the independent set problem is:</p><p class="math-container">\[H(G, \mathbf{n}) = - \sum_{v \in V} w_v n_v + \sum_{(u, v) \in E} n_u n_v\]</p><p>where <span>$n_v$</span> is the number of vertices in the independent set, i.e. <span>$n_v = 1$</span> if <span>$v$</span> is in the independent set, and <span>$n_v = 0$</span> otherwise. The larger the size of the independent set, the lower the energy.</p><p><strong>Fields</strong></p><ul><li><code>graph::AbstractGraph</code>: The problem graph.</li><li><code>weights::AbstractVector</code>: Weights associated with the vertices of the <code>graph</code>. Defaults to <code>UnitWeight(nv(graph))</code>.</li></ul><p><strong>Example</strong></p><p>In the following example, we define an independent set problem on a graph with four vertices. To define an <code>IndependentSet</code> problem, we need to specify the graph and possibily the weights associated with vertices. The weights are set as unit by default in the current version and might be generalized to arbitrary positive weights.</p><pre><code class="language-julia-repl hljs">julia&gt; using ProblemReductions, Graphs

julia&gt; graph = SimpleGraph(Graphs.SimpleEdge.([(1, 2), (1, 3), (3, 4), (2, 3)]))
{4, 4} undirected simple Int64 graph

julia&gt; IS = IndependentSet(graph)
IndependentSet{SimpleGraph{Int64}, Int64, UnitWeight}(SimpleGraph{Int64}(4, [[2, 3], [1, 3], [1, 2, 4], [3]]), [1, 1, 1, 1])

julia&gt; num_variables(IS)  # degrees of freedom
4

julia&gt; flavors(IS)  # flavors of the vertices
(0, 1)

julia&gt; solution_size(IS, [1, 0, 0, 1]) # Positive sample: -(size) of an independent set
SolutionSize{Int64}(2, true)

julia&gt; solution_size(IS, [0, 1, 1, 0]) # Negative sample: 0
SolutionSize{Int64}(2, false)

julia&gt; findbest(IS, BruteForce())  # solve the problem with brute force
2-element Vector{Vector{Int64}}:
 [1, 0, 0, 1]
 [0, 1, 0, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/ProblemReductions.jl/blob/180579b61116b3a92c52051e9a87c7619fa4c902/src/models/IndependentSet.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ProblemReductions.KSatisfiability" href="#ProblemReductions.KSatisfiability"><code>ProblemReductions.KSatisfiability</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct KSatisfiability{K, S, T, WT&lt;:(AbstractArray{T})} &lt;: AbstractSatisfiabilityProblem{S, T}</code></pre><p>The satisfiability problem for k-SAT, where the goal is to find an assignment that satisfies the CNF.</p><p><strong>Fields</strong></p><ul><li><code>symbols::Vector{T}</code>: The symbols in the CNF.</li><li><code>cnf::CNF{T}</code>: The CNF expression.</li><li><code>weights</code>: the weights associated with clauses.</li><li><code>allow_less::Bool</code>: whether to allow less than <code>k</code> literals in a clause.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/ProblemReductions.jl/blob/180579b61116b3a92c52051e9a87c7619fa4c902/src/models/Satisfiability.jl#L168">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ProblemReductions.Matching" href="#ProblemReductions.Matching"><code>ProblemReductions.Matching</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Matching{T, WT&lt;:AbstractArray{T, 1}} &lt;: ConstraintSatisfactionProblem{T}</code></pre><p>The <a href="https://queracomputing.github.io/GenericTensorNetworks.jl/dev/generated/Matching/">Vertex matching</a> problem.</p><p><strong>Positional arguments</strong></p><ul><li><code>graph</code> is the problem graph.</li><li><code>weights</code> are associated with the edges of the <code>graph</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/ProblemReductions.jl/blob/180579b61116b3a92c52051e9a87c7619fa4c902/src/models/Matching.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ProblemReductions.MaxCut" href="#ProblemReductions.MaxCut"><code>ProblemReductions.MaxCut</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct MaxCut{T, WT&lt;:AbstractArray{T, 1}} &lt;: ConstraintSatisfactionProblem{T}</code></pre><p>Max Cut problem is defined on weighted graphs. The goal is to find a partition of the vertices into two sets such that the sum of the weights of the edges between the two sets is maximized.</p><p><strong>Positional arguments</strong></p><ul><li><code>graph</code> is the problem graph.</li><li><code>weights</code> are associated with the edges of the <code>graph</code>. We have ensure that the <code>weights</code> are in the same order as the edges in <code>edges(graph)</code>.</li></ul><p><strong>Example</strong></p><p>In the following example, we solve a Max Cut problem on a complete graph with 3 vertices and edge weights <code>[1,2,3]</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; using ProblemReductions, Graphs

julia&gt; g = complete_graph(3)
{3, 3} undirected simple Int64 graph

julia&gt; maxcut = MaxCut(g,[1,2,3]) # specify the weights of the edges
MaxCut{Int64, Vector{Int64}}(SimpleGraph{Int64}(3, [[2, 3], [1, 3], [1, 2]]), [1, 2, 3])

julia&gt; mc = set_weights(maxcut, [2,1,3]) # set the weights and get a new instance
MaxCut{Int64, Vector{Int64}}(SimpleGraph{Int64}(3, [[2, 3], [1, 3], [1, 2]]), [2, 1, 3])


julia&gt; num_variables(maxcut) # return the number of vertices
3

julia&gt; flavors(maxcut) # return the flavors of the vertices
(0, 1)

julia&gt; solution_size(maxcut, [0,1,0]) # return the size of the configuration
SolutionSize{Int64}(4, true)

julia&gt; findbest(maxcut, BruteForce()) # find the best configuration
2-element Vector{Vector{Int64}}:
 [1, 1, 0]
 [0, 0, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/ProblemReductions.jl/blob/180579b61116b3a92c52051e9a87c7619fa4c902/src/models/MaxCut.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ProblemReductions.MaximalIS" href="#ProblemReductions.MaximalIS"><code>ProblemReductions.MaximalIS</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct MaximalIS{T, WT&lt;:AbstractArray{T, 1}} &lt;: ConstraintSatisfactionProblem{T}</code></pre><p>Maximal independent set is a problem that very similar to the <a href="#ProblemReductions.IndependentSet"><code>IndependentSet</code></a> problem. The difference is that the solution space of a maximal indepdent set problem does not include the independent sets that can be extended by adding one more vertex.</p><p><strong>Fields</strong></p><ul><li><code>graph</code> is the problem graph.</li><li><code>weights</code> are associated with the vertices of the <code>graph</code>.</li></ul><p><strong>Example</strong></p><p>In the following example, we define a maximal independent set problem on a graph with four vertices. To define a <code>MaximalIS</code> problem, we need to specify the graph and possibily the weights associated with vertices. The weights are set as unit by default in the current version and might be generalized to arbitrary positive weights in the following development.</p><pre><code class="language-julia-repl hljs">julia&gt; using ProblemReductions, Graphs

julia&gt; graph = SimpleGraph(Graphs.SimpleEdge.([(1, 2), (1, 3), (3, 4), (2, 3), (1, 4)]))
{4, 5} undirected simple Int64 graph

julia&gt; problem = MaximalIS(graph)
MaximalIS{Int64, UnitWeight}(SimpleGraph{Int64}(5, [[2, 3, 4], [1, 3], [1, 2, 4], [1, 3]]), [1, 1, 1, 1])

julia&gt; num_variables(problem)  # degrees of freedom
4

julia&gt; flavors(problem)
(0, 1)

julia&gt; solution_size(problem, [0, 1, 0, 0])  # unlike the independent set, this configuration is not a valid solution
SolutionSize{Int64}(1, false)

julia&gt; findbest(problem, BruteForce())
1-element Vector{Vector{Int64}}:
 [0, 1, 0, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/ProblemReductions.jl/blob/180579b61116b3a92c52051e9a87c7619fa4c902/src/models/MaximalIS.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ProblemReductions.PaintShop" href="#ProblemReductions.PaintShop"><code>ProblemReductions.PaintShop</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct PaintShop{LT} &lt;: ConstraintSatisfactionProblem{Int64}</code></pre><p>The binary paint shop problem is defined as follows: we are given a <span>$2m$</span> length sequence containing <span>$m$</span> cars, where each car appears twice. Each car need to be colored red in one occurrence, and blue in the other. We need to choose which occurrence for each car to color with which color — the goal is to minimize the number of times we need to change the current color.</p><p><strong>Fields</strong></p><ul><li><code>sequence</code> is a vector of symbols, each symbol is associated with a color.</li><li><code>isfirst</code> is a vector of boolean numbers, indicating whether the symbol is the first appearance in the sequence.</li></ul><p><strong>Example</strong></p><p>In the following example, we define a paint shop problem with 6 cars.</p><pre><code class="language-julia-repl hljs">julia&gt; using ProblemReductions

julia&gt; problem = PaintShop([&quot;a&quot;,&quot;b&quot;,&quot;a&quot;,&quot;c&quot;,&quot;c&quot;,&quot;b&quot;])
PaintShop{String}([&quot;a&quot;, &quot;b&quot;, &quot;a&quot;, &quot;c&quot;, &quot;c&quot;, &quot;b&quot;], Bool[1, 1, 0, 1, 0, 0])

julia&gt; num_variables(problem)
3

julia&gt; flavors(problem)
(0, 1)

julia&gt; solution_size(problem, [0, 1, 0])
SolutionSize{Int64}(4, true)

julia&gt; findbest(problem, BruteForce())
2-element Vector{Vector{Int64}}:
 [1, 0, 0]
 [0, 1, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/ProblemReductions.jl/blob/180579b61116b3a92c52051e9a87c7619fa4c902/src/models/Paintshop.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ProblemReductions.QUBO" href="#ProblemReductions.QUBO"><code>ProblemReductions.QUBO</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct QUBO{T&lt;:Real} &lt;: ConstraintSatisfactionProblem{T&lt;:Real}</code></pre><p>The quadratic unconstrained binary optimization.</p><p class="math-container">\[E = \sum_{i,j} Q_{ij} x_i x_j\]</p><p>where <span>$x_i \in \{0, 1\}$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>matrix::AbstractMatrix</code>: the matrix Q of the QUBO problem.</li></ul><pre><code class="language-julia-repl hljs">julia&gt; using ProblemReductions, Graphs
       # Matrix method

julia&gt; Q = [1. 0 0; 0 1 0; 0 0 1]
3×3 Matrix{Float64}:
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0

julia&gt; QUBO01 = QUBO(Q)
       # Graph method
QUBO{Float64}([1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0])

julia&gt; graph = SimpleGraph(3)
{3, 0} undirected simple Int64 graph

julia&gt; QUBO02 = QUBO(graph, Float64[], [1., 1., 1.])
QUBO{Float64}([1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0])

julia&gt; num_variables(QUBO01)  # degrees of freedom
3

julia&gt; flavors(QUBO01)  # flavors of the vertices
(0, 1)

julia&gt; solution_size(QUBO01, [0, 1, 0])
SolutionSize{Float64}(1.0, true)

julia&gt; solution_size(QUBO02, [0, 1, 0])
SolutionSize{Float64}(1.0, true)

julia&gt; findbest(QUBO01, BruteForce())  # solve the problem with brute force
1-element Vector{Vector{Int64}}:
 [0, 0, 0]

julia&gt; findbest(QUBO02, BruteForce())
1-element Vector{Vector{Int64}}:
 [0, 0, 0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/ProblemReductions.jl/blob/180579b61116b3a92c52051e9a87c7619fa4c902/src/models/QUBO.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ProblemReductions.Satisfiability" href="#ProblemReductions.Satisfiability"><code>ProblemReductions.Satisfiability</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Satisfiability{S, T, WT&lt;:(AbstractArray{T})} &lt;: AbstractSatisfiabilityProblem{S, T}</code></pre><p>Satisfiability (also called SAT) problem is to find the boolean assignment that satisfies a Conjunctive Normal Form (CNF). A tipical CNF would look like:</p><p class="math-container">\[\left(l_{11} \vee \ldots \vee l_{1 n_1}\right) \wedge \ldots \wedge\left(l_{m 1} \vee \ldots \vee l_{m n_m}\right)\]</p><p>where literals are joint by <span>$\vee$</span> to for <span>$m$</span> clauses and clauses are joint by <span>$\wedge$</span> to form a CNF.</p><p>We should note that all the SAT problem problem can be reduced to the 3-SAT problem and it can be proved that 3-SAT is NP-complete.</p><p><strong>Fields</strong></p><ul><li><code>cnf</code> is a conjunctive normal form (<a href="../ref/#ProblemReductions.CNF"><code>CNF</code></a>) for specifying the satisfiability problems.</li><li><code>weights</code> are associated with clauses.</li></ul><p><strong>Example</strong></p><p>In the following example, we define a satisfiability problem with two clauses.</p><pre><code class="language-julia-repl hljs">julia&gt; using ProblemReductions

julia&gt; bv1, bv2, bv3 = BoolVar.([&quot;x&quot;, &quot;y&quot;, &quot;z&quot;])
3-element Vector{BoolVar{String}}:
 x
 y
 z

julia&gt; clause1 = CNFClause([bv1, bv2, bv3])
x ∨ y ∨ z

julia&gt; clause2 = CNFClause([BoolVar(&quot;w&quot;), bv1, BoolVar(&quot;x&quot;, true)])
w ∨ x ∨ ¬x

julia&gt; cnf_test = CNF([clause1, clause2])
(x ∨ y ∨ z) ∧ (w ∨ x ∨ ¬x)

julia&gt; sat_test = Satisfiability(cnf_test)
Satisfiability{String, Int64, UnitWeight}([&quot;x&quot;, &quot;y&quot;, &quot;z&quot;, &quot;w&quot;], [1, 1], (x ∨ y ∨ z) ∧ (w ∨ x ∨ ¬x))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/ProblemReductions.jl/blob/180579b61116b3a92c52051e9a87c7619fa4c902/src/models/Satisfiability.jl#L107">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ProblemReductions.SetCovering" href="#ProblemReductions.SetCovering"><code>ProblemReductions.SetCovering</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct SetCovering{ET, T, WT&lt;:AbstractArray{T, 1}} &lt;: ConstraintSatisfactionProblem{T}</code></pre><p>The Set Covering problem is defined as follow: given a universe of elements and a collection of subsets of the universe, each set is associated with a weight.  The goal is to find a subset of sets that covers all the elements with the minimum total weight.</p><p><strong>Positional arguments</strong></p><ul><li><code>elements</code> is a vector of elements in the universe.</li><li><code>sets</code> is a vector of vectors, a collection of subsets of universe , each set is associated with a weight specified in <code>weights</code>.</li><li><code>weights</code> are associated with sets.</li></ul><p><strong>Example</strong></p><p>In the following example, we solve a Set Covering problem with 3 subsets and weights <code>[1,2,3]</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; using ProblemReductions

julia&gt; subsets = [[1, 2, 3], [2, 4], [1, 4]]
3-element Vector{Vector{Int64}}:
 [1, 2, 3]
 [2, 4]
 [1, 4]

julia&gt; weights = [1, 2, 3]
3-element Vector{Int64}:
 1
 2
 3

julia&gt; setcovering = SetCovering(subsets, weights)
SetCovering{Int64, Int64, Vector{Int64}}([1, 2, 3, 4], [[1, 2, 3], [2, 4], [1, 4]], [1, 2, 3])

julia&gt; num_variables(setcovering)  # degrees of freedom
3

julia&gt; solution_size(setcovering, [1, 0, 1])  # size of a configuration
SolutionSize{Int64}(4, true)

julia&gt; solution_size(setcovering, [0, 1, 1])
SolutionSize{Int64}(5, false)

julia&gt; sc = set_weights(setcovering, [1, 2, 3])  # set the weights of the subsets
SetCovering{Int64, Int64, Vector{Int64}}([1, 2, 3, 4], [[1, 2, 3], [2, 4], [1, 4]], [1, 2, 3])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/ProblemReductions.jl/blob/180579b61116b3a92c52051e9a87c7619fa4c902/src/models/SetCovering.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ProblemReductions.SetPacking" href="#ProblemReductions.SetPacking"><code>ProblemReductions.SetPacking</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct SetPacking{ET, T, WT&lt;:AbstractArray{T, 1}} &lt;: ConstraintSatisfactionProblem{T}</code></pre><p>SetPacking(elements::AbstractVector, sets::AbstractVector, weights::AbstractVector=UnitWeight(length(sets))) -&gt; SetPacking</p><p>A packing is a set of sets where each set is pairwise disjoint from each other. The maximum (weighted) packing problem is to find the maximum packing for a given union and a set of subsets.</p><p><strong>Fields</strong></p><ul><li><code>elements</code> is a vector of elements in the universe.</li><li><code>sets</code> is a vector of vectors, each set is associated with a weight specified in <code>weights</code>.</li><li><code>weights</code> are associated with sets. Defaults to <code>UnitWeight(length(sets))</code>.</li></ul><p><strong>Example</strong></p><p>In the following example, we define a set packing problem with five subsets. To define a <code>SetPacking</code> problem, we need to specify the set of subsets and possibily the weights associated with these subsets. The weights are set as unit by default in the current version and might be generalized to arbitrary positive weights in the following development. Besides, the elements would be automatically counted by the construction function.</p><pre><code class="language-julia-repl hljs">julia&gt; using ProblemReductions

julia&gt; sets = [[1, 2, 5], [1, 3], [2, 4], [3, 6], [2, 3, 6]]
5-element Vector{Vector{Int64}}:
 [1, 2, 5]
 [1, 3]
 [2, 4]
 [3, 6]
 [2, 3, 6]

julia&gt; SP = SetPacking(sets)
SetPacking{Int64, Int64, UnitWeight}([1, 2, 5, 3, 4, 6], [[1, 2, 5], [1, 3], [2, 4], [3, 6], [2, 3, 6]], [1, 1, 1, 1, 1])

julia&gt; num_variables(SP)  # degrees of freedom
5

julia&gt; flavors(SP)  # flavors of the subsets
(0, 1)

julia&gt; solution_size(SP, [1, 0, 0, 1, 0]) # Positive sample: -(size) of a packing
SolutionSize{Int64}(2, true)

julia&gt; solution_size(SP, [1, 0, 1, 1, 0]) # Negative sample: 0
SolutionSize{Int64}(3, false)

julia&gt; findbest(SP, BruteForce())  # solve the problem with brute force
3-element Vector{Vector{Int64}}:
 [0, 1, 1, 0, 0]
 [1, 0, 0, 1, 0]
 [0, 0, 1, 1, 0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/ProblemReductions.jl/blob/180579b61116b3a92c52051e9a87c7619fa4c902/src/models/SetPacking.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ProblemReductions.SpinGlass" href="#ProblemReductions.SpinGlass"><code>ProblemReductions.SpinGlass</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct SpinGlass{GT&lt;:Graphs.AbstractGraph, T, WT&lt;:AbstractArray{T, 1}} &lt;: ConstraintSatisfactionProblem{T}</code></pre><pre><code class="nohighlight hljs">SpinGlass(graph::AbstractGraph, weights::AbstractVector)
SpinGlass(graph::SimpleGraph, J, h=zeros(nv(graph)))</code></pre><p>Spin Glass is a type of disordered magnetic system that exhibits a glassy behavior. The Hamiltonian of the system on a simple graph <span>$G=(V, E)$</span> is given by</p><p class="math-container">\[H(G, \sigma) = \sum_{(i,j) \in E} J_{ij} \sigma_i \sigma_j + \sum_{i \in V} h_i \sigma_i\]</p><p>where <span>$J_{ij} \in \mathbb{R}$</span> is the coupling strength between spins <span>$i$</span> and <span>$j$</span>, <span>$h_i \in \mathbb{R}$</span> is the external field on spin <span>$i$</span>, and <span>$\sigma_i \in \{-1, 1\}$</span> is the spin variable.</p><p>This definition naturally extends to the case of a <a href="../ref/#ProblemReductions.HyperGraph"><code>HyperGraph</code></a>:</p><p class="math-container">\[H(G, \sigma) = \sum_{e \in E} J_{e} \prod_k\sigma_k + \sum_{i \in V} h_i \sigma_i,\]</p><p>where <span>$J_e$</span> is the coupling strength associated with hyperedge <span>$e$</span>, and the product is over all spins in the hyperedge.</p><p><strong>Fields</strong></p><ul><li><code>graph</code> is a graph object.</li><li><code>J</code> are the coupling strengths associated with the edges.</li><li><code>h</code> are the external fields associated with the vertices.</li></ul><p><strong>Example</strong></p><p>In the following example, we define a spin glass problem on a 4-vertex graph with given coupling strengths on edges and external fields on vertices.</p><pre><code class="language-julia-repl hljs">julia&gt; using ProblemReductions, ProblemReductions.Graphs

julia&gt; graph = SimpleGraph(Graphs.SimpleEdge.([(1, 2), (1, 3), (3, 4), (2, 3)]))
{4, 4} undirected simple Int64 graph

julia&gt; J = [1, -1, 1, -1]  # coupling strength
4-element Vector{Int64}:
  1
 -1
  1
 -1

julia&gt; h = [1, -1, -1, 1]  # external field
4-element Vector{Int64}:
  1
 -1
 -1
  1

julia&gt; spinglass = SpinGlass(graph, J, h)  # Define a spin glass problem
SpinGlass{SimpleGraph{Int64}, Int64, Vector{Int64}}(SimpleGraph{Int64}(4, [[2, 3], [1, 3], [1, 2, 4], [3]]), [1, -1, 1, -1], [1, -1, -1, 1])

julia&gt; num_variables(spinglass)  # degrees of freedom
4

julia&gt; flavors(spinglass)  # flavors of the spins
(1, -1)

julia&gt; solution_size(spinglass, [-1, 1, 1, -1])  # size of a configuration
SolutionSize{Int64}(-2, true)

julia&gt; findbest(spinglass, BruteForce())  # solve the problem with brute force
1-element Vector{Vector{Int64}}:
 [-1, 1, -1, -1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/ProblemReductions.jl/blob/180579b61116b3a92c52051e9a87c7619fa4c902/src/models/SpinGlass.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ProblemReductions.VertexCovering" href="#ProblemReductions.VertexCovering"><code>ProblemReductions.VertexCovering</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct VertexCovering{T, WT&lt;:AbstractArray{T, 1}} &lt;: ConstraintSatisfactionProblem{T}</code></pre><p>A Vertex Cover is a subset of vertices in a graph, such that for an arbitrary edge, the subset includes at least one of the endpoints. The minimum vertex covering problem is to find the minimum vertex cover for a given graph, which is a NP-complete problem.</p><p><strong>Fields</strong></p><ul><li><code>graph</code> is a graph object.</li><li><code>weights</code> are associated with the vertices of the <code>graph</code>, default to <code>UnitWeight(nv(graph))</code>.</li></ul><p><strong>Example</strong></p><p>In the following example, we define a vertex covering problem on a graph with four vertices. To define a <code>VertexCovering</code> problem, we need to specify the graph and the weights associated with edges. The weights are by default set as unit.</p><pre><code class="language-julia-repl hljs">julia&gt; using ProblemReductions, Graphs

julia&gt; graph = SimpleGraph(Graphs.SimpleEdge.([(1,2), (1,3), (3,4), (2,3), (1,4)]))
{4, 5} undirected simple Int64 graph

julia&gt; weights = [1, 3, 1, 4]
4-element Vector{Int64}:
 1
 3
 1
 4

julia&gt; VC= VertexCovering(graph, weights)
VertexCovering{Int64, Vector{Int64}}(SimpleGraph{Int64}(5, [[2, 3, 4], [1, 3], [1, 2, 4], [1, 3]]), [1, 3, 1, 4])

julia&gt; num_variables(VC)  # degrees of freedom
4

julia&gt; solution_size(VC, [1, 0, 0, 1]) # Negative sample
SolutionSize{Int64}(5, false)

julia&gt; solution_size(VC, [0, 1, 1, 0]) # Positive sample
SolutionSize{Int64}(4, false)

julia&gt; findbest(VC, BruteForce())  # solve the problem with brute force
1-element Vector{Vector{Int64}}:
 [1, 0, 1, 0]

julia&gt; VC02 = set_weights(VC, [1, 2, 3, 4])  # set the weights of the subsets
VertexCovering{Int64, Vector{Int64}}(SimpleGraph{Int64}(5, [[2, 3, 4], [1, 3], [1, 2, 4], [1, 3]]), [1, 2, 3, 4])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/ProblemReductions.jl/blob/180579b61116b3a92c52051e9a87c7619fa4c902/src/models/VertexCovering.jl#L1">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../rules/independentset_setpacking/">« Independent Set -&gt; Set Packing</a><a class="docs-footer-nextpage" href="../ref/">Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Friday 27 December 2024 17:26">Friday 27 December 2024</span>. Using Julia version 1.10.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
