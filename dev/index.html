<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · ProblemReductions.jl</title><meta name="title" content="Home · ProblemReductions.jl"/><meta property="og:title" content="Home · ProblemReductions.jl"/><meta property="twitter:title" content="Home · ProblemReductions.jl"/><meta name="description" content="Documentation for ProblemReductions.jl."/><meta property="og:description" content="Documentation for ProblemReductions.jl."/><meta property="twitter:description" content="Documentation for ProblemReductions.jl."/><meta property="og:url" content="https://GiggleLiu.github.io/ProblemReductions.jl/"/><meta property="twitter:url" content="https://GiggleLiu.github.io/ProblemReductions.jl/"/><link rel="canonical" href="https://GiggleLiu.github.io/ProblemReductions.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>ProblemReductions.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Framework"><span>Framework</span></a></li><li><a class="tocitem" href="#Model-Problems"><span>Model Problems</span></a></li><li><a class="tocitem" href="#Reduction-Rules"><span>Reduction Rules</span></a></li></ul></li><li><span class="tocitem">Models</span><ul><li><a class="tocitem" href="models/CircuitSAT/">Circuit Satisfaction</a></li><li><a class="tocitem" href="models/Coloring/">Vertex Coloring</a></li><li><a class="tocitem" href="models/Factoring/">Prime Factorization</a></li><li><a class="tocitem" href="models/MaxCut/">Max Cut</a></li><li><a class="tocitem" href="models/SetCovering/">Set Covering</a></li><li><a class="tocitem" href="models/SpinGlass/">Spin Glass</a></li><li><a class="tocitem" href="models/Satisfiability/">Satisfiability</a></li><li><a class="tocitem" href="models/QUBO/">Quadratic Unconstrained Binary Optimization</a></li><li><a class="tocitem" href="models/SetPacking/">Set Packing</a></li><li><a class="tocitem" href="models/DominatingSet/">Dominating Set</a></li><li><a class="tocitem" href="models/IndependentSet/">Independent Set</a></li><li><a class="tocitem" href="models/VertexCovering/">Vertex Covering</a></li></ul></li><li><span class="tocitem">Rules</span><ul><li><a class="tocitem" href="rules/spinglass_sat/">CircuitSAT -&gt; SpinGlass</a></li><li><a class="tocitem" href="rules/independentset_setpacking/">Independent Set -&gt; Set Packing</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="generated/Ising/">Solving Factoring problem with Ising machine</a></li></ul></li><li><a class="tocitem" href="ref/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/GiggleLiu/ProblemReductions.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/GiggleLiu/ProblemReductions.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="ProblemReductions"><a class="docs-heading-anchor" href="#ProblemReductions">ProblemReductions</a><a id="ProblemReductions-1"></a><a class="docs-heading-anchor-permalink" href="#ProblemReductions" title="Permalink"></a></h1><p>This is the documentation for the open source package <a href="https://github.com/GiggleLiu/ProblemReductions.jl">ProblemReductions</a>, a package for the reduction (or transformation) between computational hard problems. Although the reduction is a common concept in the field of computational complexity, every textbook on this topic defines its own set of problems and reduction rules. Unfortunately, these rules are not directly accessible to the public, especially for people in fields such as quantum many-body physics and statistical physics. This package aims to collect a set of well-known problems and their reductions in one place, and provide a unified interface to access them. We hope this will lower the barrier for researchers to enter this fascinating field.</p><h2 id="Framework"><a class="docs-heading-anchor" href="#Framework">Framework</a><a id="Framework-1"></a><a class="docs-heading-anchor-permalink" href="#Framework" title="Permalink"></a></h2><p>ProblemReductions defines a set of <strong>computational hard problems</strong> and the <strong>reduction rules</strong> between them. In the following diagram, we use an arrow pointing from problem A to problem B to indicate that there is a reduction rule from problem A to problem B.</p><p><img src="assets/reduction.svg" alt/></p><p>The reduction rules induce a directed graph, called the <strong>reduction graph</strong>, where the nodes are the problems and the edges are the reductions. Problem A can be reduced to problem B if and only if there is a path from A to B. This reduction may consist of multiple steps, and the reduction path may not be unique.</p><p>The following example shows how to use the package to solve a simple factoring problem <span>$? \times ? = 3$</span> by reducing it to an Ising model.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using ProblemReductions</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; factoring = Factoring(2, 1, 3)  # define the factoring problem</code><code class="nohighlight hljs ansi" style="display:block;">Factoring(2, 1, 3)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; paths = reduction_paths(Factoring, SpinGlass);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; length(paths)   # you may find multiple reduction paths</code><code class="nohighlight hljs ansi" style="display:block;">2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; res = reduceto(paths[1], factoring); # perform the reduction</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; problem_size(target_problem(res))</code><code class="nohighlight hljs ansi" style="display:block;">(num_vertices = 25, num_edges = 47)</code></pre><p>The <a href="ref/#ProblemReductions.Factoring"><code>Factoring</code></a> problem is defined with two inputs of bit width 2 and 1, respectively. We first query the reduction paths from the <a href="ref/#ProblemReductions.Factoring">Factoring</a> problem to the <a href="ref/#ProblemReductions.SpinGlass">SpinGlass</a> problem using <a href="ref/#ProblemReductions.reduction_paths-Union{Tuple{S}, Tuple{T}, Tuple{Type{S}, Type{T}}} where {T&lt;:AbstractProblem, S&lt;:AbstractProblem}"><code>reduction_paths</code></a>, and find multiple paths. Each path is a <a href="ref/#ProblemReductions.ReductionPath"><code>ReductionPath</code></a> instance. We pick one reduction path and perform the reduction using <a href="ref/#ProblemReductions.reduceto"><code>reduceto</code></a>. The result is a <a href="ref/#ProblemReductions.ConcatenatedReduction"><code>ConcatenatedReduction</code></a> instance, which contains not only the target problem, but also the intermediate reductions in the reduction path. The target problem is an Ising model with 25 spins, which is exactly solvable using the <a href="ref/#ProblemReductions.BruteForce"><code>BruteForce</code></a> method implemented in <a href="ref/#ProblemReductions.findbest"><code>findbest</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; sol = findbest(target_problem(res), BruteForce()); # solve the target problem

julia&gt; extract_solution.(Ref(res), sol) # extract the solution to the original problem
1-element Vector{Vector{Int64}}:
 [1, 1, 1]</code></pre><p>The solution to the original problem is extracted using <a href="ref/#ProblemReductions.extract_solution"><code>extract_solution</code></a>. Note that the <code>findbest</code> funciton returns a set of equally good solutions, so broadcasting is used here.</p><h2 id="Model-Problems"><a class="docs-heading-anchor" href="#Model-Problems">Model Problems</a><a id="Model-Problems-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Problems" title="Permalink"></a></h2><p>A model problem is a subclass of <a href="ref/#ProblemReductions.AbstractProblem"><code>AbstractProblem</code></a> that defines the energy function of a computational problem. Facts affecting the computational complexity classification of the problem also include the topology of the problem and the domain of the variables.</p><p>The required interfaces are:</p><ul><li><a href="ref/#ProblemReductions.variables"><code>variables</code></a>: The degrees of freedoms in the problem.   e.g. for the maximum independent set problems, they are the indices of vertices: 1, 2, 3...,   while for the max cut problem, they are the edges.</li><li><a href="ref/#ProblemReductions.flavors-Tuple{GT} where GT&lt;:AbstractProblem"><code>flavors</code></a>: A vector of integers as the flavors (or domain) of a degree of freedom.   e.g. for the maximum independent set problems, the flavors are [0, 1], where 0 means the vertex is not in the set and 1 means the vertex is in the set.</li><li><a href="ref/#ProblemReductions.weights"><code>weights</code></a>: Energies associated with constraints.</li><li><a href="ref/#ProblemReductions.energy"><code>energy</code></a>: Energy of a given configuration.</li><li><a href="ref/#ProblemReductions.problem_size"><code>problem_size</code></a>: The size of the problem, which is the number of variables.</li></ul><p>Optional functions include:</p><ul><li><a href="ref/#ProblemReductions.num_variables-Tuple{AbstractProblem}"><code>num_variables</code></a>: The number of variables in the problem.</li><li><a href="ref/#ProblemReductions.num_flavors-Tuple{GT} where GT&lt;:AbstractProblem"><code>num_flavors</code></a>: The number of flavors in the problem.</li><li><a href="ref/#ProblemReductions.set_weights"><code>set_weights</code></a>: Change the weights for the <code>problem</code> and return a new problem instance.</li><li><a href="ref/#ProblemReductions.weight_type-Tuple{AbstractProblem}"><code>weight_type</code></a>: The data type of weights.</li><li><a href="ref/#ProblemReductions.findbest"><code>findbest</code></a>: Find the best configurations in the computational problem.</li></ul><p>The following code lists all problems defined in ProblemReductions:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ProblemReductions.concrete_subtypes(AbstractProblem)</code><code class="nohighlight hljs ansi" style="display:block;">16-element Vector{Any}:
 CircuitSAT
 Coloring
 DominatingSet
 IndependentSet
 Matching
 MaxCut
 MaximalIS
 PaintShop
 KSatisfiability
 Satisfiability
 QUBO
 SetCovering
 SetPacking
 SpinGlass
 VertexCovering
 Factoring</code></pre><h3 id="Graph-Topology"><a class="docs-heading-anchor" href="#Graph-Topology">Graph Topology</a><a id="Graph-Topology-1"></a><a class="docs-heading-anchor-permalink" href="#Graph-Topology" title="Permalink"></a></h3><p>Model problems are often defined on graphs. When limiting a model problem to a specific graph topology, the hardness of the problem can be drastically different. To handle this, we define the following graph types:</p><ul><li><a href="https://juliagraphs.org/Graphs.jl/dev/core_functions/simplegraphs/#Graphs.SimpleGraphs.SimpleGraph"><code>SimpleGraph</code></a>: A simple graph is an undirected graph with no self-loops or multiple edges between the same pair of vertices.</li><li><a href="ref/#ProblemReductions.HyperGraph"><code>HyperGraph</code></a>: A hypergraph is a generalization of a graph in which an edge can connect any number of vertices.</li><li><a href="ref/#ProblemReductions.UnitDiskGraph"><code>UnitDiskGraph</code></a>: A unit disk graph is a graph in which vertices are placed in the Euclidean plane and edges are drawn between vertices that are within a fixed distance of each other. Similarly, we have an alias <a href="ref/#ProblemReductions.GridGraph"><code>GridGraph</code></a> for unit disk graphs with integer coordinates (i.e. vertices are placed on a grid).</li></ul><p><img src="assets/graphtypes.svg" alt/></p><p>To define a graph topology, the minimum required functions are: <code>vertices</code> and <code>edges</code>. More interfaces are specified in the <a href="https://juliagraphs.org/Graphs.jl/dev/"><code>Graphs</code></a> package.</p><h2 id="Reduction-Rules"><a class="docs-heading-anchor" href="#Reduction-Rules">Reduction Rules</a><a id="Reduction-Rules-1"></a><a class="docs-heading-anchor-permalink" href="#Reduction-Rules" title="Permalink"></a></h2><p>A problem reduction rule is a function that reduces a problem to another problem. By solving the target problem, we can extract the solution to the original problem. The reduction rule is defined as a function that takes an instance of the original problem and returns an <a href="ref/#ProblemReductions.AbstractReductionResult"><code>AbstractReductionResult</code></a> instance of the target problem.</p><ul><li><a href="ref/#ProblemReductions.reduceto"><code>reduceto</code></a>: Reduce the source problem to a target problem of a specific type. Returns an <a href="ref/#ProblemReductions.AbstractReductionResult"><code>AbstractReductionResult</code></a> instance, which contains the target problem.</li><li><a href="ref/#ProblemReductions.target_problem"><code>target_problem</code></a>: Return the target problem of the reduction result.</li><li><a href="ref/#ProblemReductions.extract_solution"><code>extract_solution</code></a>: Extract the solution to the target problem back to the original problem.</li></ul><p>Optional functions include:</p><ul><li><a href="ref/#ProblemReductions.extract_multiple_solutions-Tuple{AbstractReductionResult, Any}"><code>extract_multiple_solutions</code></a>: Extract a set of solutions to the target problem back to the original problem. You may want to implement this when you want to make extracting multiple solutions faster.</li><li><a href="ref/#ProblemReductions.reduce_size-Union{Tuple{TA}, Tuple{Type{TA}, AbstractProblem}} where TA&lt;:AbstractProblem"><code>reduce_size</code></a>: Infer the size of the target problem from the source problem size.</li></ul><p>The <a href="ref/#ProblemReductions.reduction_graph-Tuple{}"><code>reduction_graph</code></a> function returns the reduction graph of the problems that induced by the reduction rules defined in ProblemReductions:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ProblemReductions.reduction_graph().graph</code><code class="nohighlight hljs ansi" style="display:block;">{21, 20} directed simple Int64 graph</code></pre><p>The number of rules is the same as the number of edges in the output graph. Both the problem set, and the reduction rules are designed to be extensible, so that users can easily add new problems and reductions to the package.</p><p>It is worth noting that <em>the reduction graph changes whenever there is a new <code>reduceto</code> function is added, regardless it is in this package or by users</em>. This is because the reduction graph checks all method tables of the <code>reduceto</code> function, and will automatically add new nodes and edges when a new problem type or reduction method is added.</p></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="models/CircuitSAT/">Circuit Satisfaction »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Thursday 28 November 2024 05:30">Thursday 28 November 2024</span>. Using Julia version 1.10.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
