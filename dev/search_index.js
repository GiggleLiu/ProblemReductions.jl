var documenterSearchIndex = {"docs":
[{"location":"generated/material_compute/","page":"Surface Programmable Materials","title":"Surface Programmable Materials","text":"EditURL = \"../../../examples/material_compute.jl\"","category":"page"},{"location":"generated/material_compute/#Surface-Programmable-Materials","page":"Surface Programmable Materials","title":"Surface Programmable Materials","text":"","category":"section"},{"location":"generated/material_compute/","page":"Surface Programmable Materials","title":"Surface Programmable Materials","text":"This is an example to be written.","category":"page"},{"location":"generated/material_compute/","page":"Surface Programmable Materials","title":"Surface Programmable Materials","text":"using ProblemReductions","category":"page"},{"location":"generated/material_compute/","page":"Surface Programmable Materials","title":"Surface Programmable Materials","text":"","category":"page"},{"location":"generated/material_compute/","page":"Surface Programmable Materials","title":"Surface Programmable Materials","text":"This page was generated using Literate.jl.","category":"page"},{"location":"models/QUBO/#Quadratic-Unconstrained-Binary-Optimization","page":"Quadratic Unconstrained Binary Optimization","title":"Quadratic Unconstrained Binary Optimization","text":"","category":"section"},{"location":"models/QUBO/#Problem-Definition","page":"Quadratic Unconstrained Binary Optimization","title":"Problem Definition","text":"","category":"section"},{"location":"models/QUBO/","page":"Quadratic Unconstrained Binary Optimization","title":"Quadratic Unconstrained Binary Optimization","text":"Quadratic Unconstrained Binary Optimization (QUBO) is a boolean optimization problem. The objective is to maximize or minimize the following quadratic form by varying x:","category":"page"},{"location":"models/QUBO/","page":"Quadratic Unconstrained Binary Optimization","title":"Quadratic Unconstrained Binary Optimization","text":"y = x^T Q x","category":"page"},{"location":"models/QUBO/","page":"Quadratic Unconstrained Binary Optimization","title":"Quadratic Unconstrained Binary Optimization","text":"where x is a n-dimensional boolean vector and Q is a real square matrix. Without loss of generality, we focus on the minimization in this package. This problem is naturally similar with the spin glass problem on a hypergraph except that the flavors are (0 1) rather than (-11). We can notice that Q is the adjacency matrix, where the diagonal terms correspond to the external magnetic field.","category":"page"},{"location":"models/QUBO/#Interfaces","page":"Quadratic Unconstrained Binary Optimization","title":"Interfaces","text":"","category":"section"},{"location":"models/QUBO/","page":"Quadratic Unconstrained Binary Optimization","title":"Quadratic Unconstrained Binary Optimization","text":"To define a QUBO problem, there are two ways:","category":"page"},{"location":"models/QUBO/","page":"Quadratic Unconstrained Binary Optimization","title":"Quadratic Unconstrained Binary Optimization","text":"We can directly specify the Q matrix;\nOr we can specify a simple graph and the weights associated with edges.","category":"page"},{"location":"models/QUBO/","page":"Quadratic Unconstrained Binary Optimization","title":"Quadratic Unconstrained Binary Optimization","text":"using ProblemReductions, Graphs\n# Matrix method\nQ = [1. 0 0; 0 1 0; 0 0 1]\nQUBO01 = QUBO(Q)\n# Graph method\ngraph = SimpleGraph(3)\nQUBO02 = QUBO(graph, Float64[], [1., 1., 1.])","category":"page"},{"location":"models/QUBO/","page":"Quadratic Unconstrained Binary Optimization","title":"Quadratic Unconstrained Binary Optimization","text":"Besides, the required functions, variables, flavors, and evaluate, and optional functions, findbest, are implemented for the [QUBO] problem.","category":"page"},{"location":"models/QUBO/","page":"Quadratic Unconstrained Binary Optimization","title":"Quadratic Unconstrained Binary Optimization","text":"variables(QUBO01)  # degrees of freedom\nvariables(QUBO02)\nflavors(QUBO01)  # flavors of the vertices\nevaluate(QUBO01, [0, 1, 0])\nevaluate(QUBO02, [0, 1, 0]) \nfindbest(QUBO01, BruteForce())  # solve the problem with brute force\nfindbest(QUBO02, BruteForce()) ","category":"page"},{"location":"models/SetCovering/#Set-Covering","page":"Set Covering","title":"Set Covering","text":"","category":"section"},{"location":"models/SetCovering/#Problem-Definition","page":"Set Covering","title":"Problem Definition","text":"","category":"section"},{"location":"models/SetCovering/","page":"Set Covering","title":"Set Covering","text":"The SetCovering problem is a combinatorial optimization problem that arises in many practical applications. It's in the class of NP-Complete and heuristic or approximation algorithms are often used to find solutions.","category":"page"},{"location":"models/SetCovering/#Interfaces","page":"Set Covering","title":"Interfaces","text":"","category":"section"},{"location":"models/SetCovering/","page":"Set Covering","title":"Set Covering","text":"Initialize a SetCovering instance needs to specify the subsets and the weights of the subsets. ","category":"page"},{"location":"models/SetCovering/","page":"Set Covering","title":"Set Covering","text":"using ProblemReductions\nsubsets = [[1, 2, 3], [2, 4], [1, 4]]\nweights = [1, 2, 3]\nsetcovering = SetCovering(subsets, weights)","category":"page"},{"location":"models/SetCovering/","page":"Set Covering","title":"Set Covering","text":"Use 2-dimensional vector to represent the subsets.","category":"page"},{"location":"models/SetCovering/","page":"Set Covering","title":"Set Covering","text":"The required functions, variables, evaluate, and optional functions:set_parameters are implemented for the set covering problem.","category":"page"},{"location":"models/SetCovering/","page":"Set Covering","title":"Set Covering","text":"variables(setcovering)  # degrees of freedom\nevaluate(setcovering, [1, 0, 1])  # cost of a configuration\nevaluate(setcovering, [0, 1, 1]) \nsc = set_parameters(setcovering, [1, 2, 3])  # set the weights of the subsets","category":"page"},{"location":"models/SetCovering/","page":"Set Covering","title":"Set Covering","text":"note: Note\nThe evaluate function returns the cost of a configuration. If the configuration is not a set cover, it returns a large number.","category":"page"},{"location":"models/DominatingSet/#Dominating-Set","page":"Dominating Set","title":"Dominating Set","text":"","category":"section"},{"location":"models/DominatingSet/#Problem-Definition","page":"Dominating Set","title":"Problem Definition","text":"","category":"section"},{"location":"models/DominatingSet/","page":"Dominating Set","title":"Dominating Set","text":"Dominaing Set is a subset of vertices in a undirected graph such that all the vertices in the set are either in the dominating set or in its first-order neighborhood. The DominatingSet problem is to find the dominating set with minimum number of vertices.","category":"page"},{"location":"models/DominatingSet/#Interfaces","page":"Dominating Set","title":"Interfaces","text":"","category":"section"},{"location":"models/DominatingSet/","page":"Dominating Set","title":"Dominating Set","text":"To define a DominatingSet problem, we need to specify the graph and possibily the weights associated with vertices. The weights are set as unit by default in the current version and might be generalized to arbitrary positive weights in the following development.","category":"page"},{"location":"models/DominatingSet/","page":"Dominating Set","title":"Dominating Set","text":"using ProblemReductions, Graphs\ngraph = SimpleGraph(5)\nadd_edge!(graph, 1, 2)\nadd_edge!(graph, 2, 3)\nadd_edge!(graph, 3, 4)\nadd_edge!(graph, 4, 5)\nDS = DominatingSet(graph)","category":"page"},{"location":"models/DominatingSet/","page":"Dominating Set","title":"Dominating Set","text":"Besides, the required functions, variables, flavors, and evaluate, and optional functions, findbest, are implemented for the Dominating Set problem.","category":"page"},{"location":"models/DominatingSet/","page":"Dominating Set","title":"Dominating Set","text":"variables(DS)  # degrees of freedom\nflavors(DS)  # flavors of the vertices\nevaluate(DS, [0, 1, 0, 1, 0]) # Positive sample: (size) of a dominating set\nevaluate(DS, [0, 1, 1, 0, 0]) # Negative sample: number of vertices\nfindbest(DS, BruteForce())  # solve the problem with brute force","category":"page"},{"location":"models/SpinGlass/#Spin-Glass","page":"Spin Glass","title":"Spin Glass","text":"","category":"section"},{"location":"models/SpinGlass/#Problem-Definition","page":"Spin Glass","title":"Problem Definition","text":"","category":"section"},{"location":"models/SpinGlass/","page":"Spin Glass","title":"Spin Glass","text":"Spin Glass is a type of disordered magnetic system that exhibits a glassy behavior. The Hamiltonian of the system on a simple graph G is given by","category":"page"},{"location":"models/SpinGlass/","page":"Spin Glass","title":"Spin Glass","text":"H(G sigma) = sum_(ij) in E(G) J_ij sigma_i sigma_j","category":"page"},{"location":"models/SpinGlass/","page":"Spin Glass","title":"Spin Glass","text":"where J_ij is the coupling strength between spins i and j and sigma_i is the spin variable that can take values in -1 1.","category":"page"},{"location":"models/SpinGlass/","page":"Spin Glass","title":"Spin Glass","text":"This definition naturally extends to the case of a HyperGraph.","category":"page"},{"location":"models/SpinGlass/#Interfaces","page":"Spin Glass","title":"Interfaces","text":"","category":"section"},{"location":"models/SpinGlass/","page":"Spin Glass","title":"Spin Glass","text":"To define a SpinGlass problem, we need to specify the graph, the coupling strength J_ij, and possibly the external field h_i for each spin i.","category":"page"},{"location":"models/SpinGlass/","page":"Spin Glass","title":"Spin Glass","text":"using ProblemReductions, ProblemReductions.Graphs\n\ngraph = smallgraph(:petersen)\nJ = rand([1, -1], ne(graph))  # coupling strength\nh = rand([1, -1], nv(graph))  # external field\nspinglass = SpinGlass(graph, J, h)  # Define a spin glass problem","category":"page"},{"location":"models/SpinGlass/","page":"Spin Glass","title":"Spin Glass","text":"Here, we also define an external field h_i for each spin i. The resulting spin glass problem is defined on a HyperGraph, where external fields are associated with hyperedges connecting single spins.","category":"page"},{"location":"models/SpinGlass/","page":"Spin Glass","title":"Spin Glass","text":"The required functions, variables, flavors, and evaluate, and optional functions, findbest, are implemented for the spin glass problem.","category":"page"},{"location":"models/SpinGlass/","page":"Spin Glass","title":"Spin Glass","text":"variables(spinglass)  # degrees of freedom\nflavors(spinglass)  # flavors of the spins\nevaluate(spinglass, [-1, 1, 1, -1, 1, 1, 1, -1, -1, 1])  # energy of a configuration\nfindbest(spinglass, BruteForce())  # solve the problem with brute force","category":"page"},{"location":"models/#Model-Problem","page":"Model Problem","title":"Model Problem","text":"","category":"section"},{"location":"models/","page":"Model Problem","title":"Model Problem","text":"A model problem is a subclass of AbstractProblem that defines the energy function of a computational problem. Facts affecting the computational complexity classification of the problem also include the topology of the problem and the domain of the variables.","category":"page"},{"location":"models/#Interfaces","page":"Model Problem","title":"Interfaces","text":"","category":"section"},{"location":"models/","page":"Model Problem","title":"Model Problem","text":"Required functions include:","category":"page"},{"location":"models/","page":"Model Problem","title":"Model Problem","text":"variables: The degrees of freedoms in the problem.   e.g. for the maximum independent set problems, they are the indices of vertices: 1, 2, 3...,   while for the max cut problem, they are the edges.\nflavors: A vector of integers as the flavors (or domain) of a degree of freedom.   e.g. for the maximum independent set problems, the flavors are [0, 1], where 0 means the vertex is not in the set and 1 means the vertex is in the set.\nparameters: Energies associated with terms.\nevaluate: Evaluate the energy of a given configuration.","category":"page"},{"location":"models/","page":"Model Problem","title":"Model Problem","text":"Optional functions include:","category":"page"},{"location":"models/","page":"Model Problem","title":"Model Problem","text":"num_variables: The number of variables in the problem.\nnum_flavors: The number of flavors in the problem.\nset_parameters: Change the parameters for the problem and return a new problem instance.\nparameter_type: The data type of parameters.\nfindbest: Find the best configurations in the computational problem.","category":"page"},{"location":"models/SetPacking/#Set-Packing","page":"Set Packing","title":"Set Packing","text":"","category":"section"},{"location":"models/SetPacking/#Problem-Definition","page":"Set Packing","title":"Problem Definition","text":"","category":"section"},{"location":"models/SetPacking/","page":"Set Packing","title":"Set Packing","text":"A packing is a set of sets where each set is pairwise disjoint from each other. The SetPacking problem is to find the maximum packing for a given union and a set of subsets.","category":"page"},{"location":"models/SetPacking/#Interfaces","page":"Set Packing","title":"Interfaces","text":"","category":"section"},{"location":"models/SetPacking/","page":"Set Packing","title":"Set Packing","text":"To define a SetPacking problem, we need to specify the set of subsets and possibily the weights associated with these subsets. The weights are set as unit by default in the current version and might be generalized to arbitrary positive weights in the following development. Besides, the elements would be automatically counted by the construction function. ","category":"page"},{"location":"models/SetPacking/","page":"Set Packing","title":"Set Packing","text":"using ProblemReductions\nsets = [[1, 2, 5], [1, 3], [2, 4], [3, 6], [2, 3, 6]]\nSP = SetPacking(sets)","category":"page"},{"location":"models/SetPacking/","page":"Set Packing","title":"Set Packing","text":"Then, the required functions, variables, flavors, and evaluate, and optional functions, findbest, are implemented for the Set Packing problem.","category":"page"},{"location":"models/SetPacking/","page":"Set Packing","title":"Set Packing","text":"variables(SP)  # degrees of freedom\nflavors(SP)  # flavors of the subsets\nevaluate(SP, [1, 0, 0, 1, 0]) # Positive sample: -(size) of a packing\nevaluate(SP, [1, 0, 1, 1, 0]) # Negative sample: 0\nfindbest(SP, BruteForce())  # solve the problem with brute force","category":"page"},{"location":"rules/spinglass_sat/#CircuitSAT-SpinGlass","page":"CircuitSAT -> SpinGlass","title":"CircuitSAT -> SpinGlass","text":"","category":"section"},{"location":"rules/spinglass_sat/","page":"CircuitSAT -> SpinGlass","title":"CircuitSAT -> SpinGlass","text":"In this tutorial, we will demonstrate how to use the Spinglass model to solve the circuit satisfiability problem.","category":"page"},{"location":"rules/spinglass_sat/","page":"CircuitSAT -> SpinGlass","title":"CircuitSAT -> SpinGlass","text":"We first define a simple Circuit using the @circuit macro. And then we convert the circuit to a CircuitSAT problem.","category":"page"},{"location":"rules/spinglass_sat/","page":"CircuitSAT -> SpinGlass","title":"CircuitSAT -> SpinGlass","text":"using ProblemReductions\n\ncircuit = @circuit begin\n    c = x ∧ y\n    d = x ∨ (¬c ∧ ¬z)\nend\ncircuitsat = CircuitSAT(circuit)\nvariables(circuitsat)\ncircuitsat.symbols","category":"page"},{"location":"rules/spinglass_sat/","page":"CircuitSAT -> SpinGlass","title":"CircuitSAT -> SpinGlass","text":"The resulting circuitsat expands the expression to a list of simple clauses. The variables are mapped to integers that pointing to the symbols that stored in the symbols field.","category":"page"},{"location":"rules/spinglass_sat/","page":"CircuitSAT -> SpinGlass","title":"CircuitSAT -> SpinGlass","text":"The we can convert the circuit to a SpinGlass problem using the reduceto function.","category":"page"},{"location":"rules/spinglass_sat/","page":"CircuitSAT -> SpinGlass","title":"CircuitSAT -> SpinGlass","text":"result = reduceto(SpinGlass, circuitsat)","category":"page"},{"location":"rules/spinglass_sat/","page":"CircuitSAT -> SpinGlass","title":"CircuitSAT -> SpinGlass","text":"The resulting result is a ReductionCircuitToSpinGlass instance that contains the spin glass problem.","category":"page"},{"location":"rules/spinglass_sat/","page":"CircuitSAT -> SpinGlass","title":"CircuitSAT -> SpinGlass","text":"With the result instance, we can define a logic gadget that maps the spin glass variables to the circuit variables.","category":"page"},{"location":"rules/spinglass_sat/","page":"CircuitSAT -> SpinGlass","title":"CircuitSAT -> SpinGlass","text":"indexof(x) = findfirst(==(findfirst(==(x), circuitsat.symbols)), result.variables)\ngadget = LogicGadget(result.spinglass, indexof.([:x, :y, :z]), [indexof(:d)])\ntb = truth_table(gadget; variables=circuitsat.symbols[result.variables])","category":"page"},{"location":"rules/spinglass_sat/","page":"CircuitSAT -> SpinGlass","title":"CircuitSAT -> SpinGlass","text":"The gadget is a LogicGadget instance that maps the spin glass variables to the circuit variables. The truth_table function generates the truth table of the gadget.","category":"page"},{"location":"topology/#Graph-Topology","page":"Graph Topology","title":"Graph Topology","text":"","category":"section"},{"location":"topology/","page":"Graph Topology","title":"Graph Topology","text":"SimpleGraph: A simple graph is an undirected graph with no self-loops or multiple edges between the same pair of vertices.\nHyperGraph: A hypergraph is a generalization of a graph in which an edge can connect any number of vertices.\nUnitDiskGraph: A unit disk graph is a graph in which vertices are placed in the Euclidean plane and edges are drawn between vertices that are within a fixed distance of each other.\nGridGraph: A grid graph is a graph in which vertices are placed on a grid and edges are drawn between vertices that are adjacent in the grid.","category":"page"},{"location":"topology/#Interfaces","page":"Graph Topology","title":"Interfaces","text":"","category":"section"},{"location":"topology/","page":"Graph Topology","title":"Graph Topology","text":"The minimum required functions for a graph are:","category":"page"},{"location":"topology/","page":"Graph Topology","title":"Graph Topology","text":"vertices: The vertices in the graph.\nedges: The edges in the graph.","category":"page"},{"location":"topology/","page":"Graph Topology","title":"Graph Topology","text":"Optional functions include:","category":"page"},{"location":"topology/","page":"Graph Topology","title":"Graph Topology","text":"ne: The number of edges in the graph.\nnv: The number of vertices in the graph.","category":"page"},{"location":"topology/","page":"Graph Topology","title":"Graph Topology","text":"These interfaces are defined in the Graphs package.","category":"page"},{"location":"models/IndependentSet/#Independent-Set","page":"Independent Set","title":"Independent Set","text":"","category":"section"},{"location":"models/IndependentSet/#Problem-Definition","page":"Independent Set","title":"Problem Definition","text":"","category":"section"},{"location":"models/IndependentSet/","page":"Independent Set","title":"Independent Set","text":"Independent Set is a subset of vertices in a undirected graph such that all the vertices in the set are not connected by edges (or called not adjacent). The IndependentSet problem is to find the independent set with maximum number of vertices.","category":"page"},{"location":"models/IndependentSet/#Interfaces","page":"Independent Set","title":"Interfaces","text":"","category":"section"},{"location":"models/IndependentSet/","page":"Independent Set","title":"Independent Set","text":"To define an IndependentSet problem, we need to specify the graph and possibily the weights associated with vertices. The weights are set as unit by default in the current version and might be generalized to arbitrary positive weights in the following development.","category":"page"},{"location":"models/IndependentSet/","page":"Independent Set","title":"Independent Set","text":"using ProblemReductions, Graphs\ngraph = SimpleGraph(4)\nadd_edge!(graph, 1, 2) \nadd_edge!(graph, 1, 3)\nadd_edge!(graph, 3, 4)\nadd_edge!(graph, 2, 3)\nIS = IndependentSet(graph)","category":"page"},{"location":"models/IndependentSet/","page":"Independent Set","title":"Independent Set","text":"Besides, the required functions, variables, flavors, and evaluate, and optional functions, findbest, are implemented for the Independent Set problem.","category":"page"},{"location":"models/IndependentSet/","page":"Independent Set","title":"Independent Set","text":"variables(IS)  # degrees of freedom\nflavors(IS)  # flavors of the vertices\nevaluate(IS, [1, 0, 0, 1]) # Positive sample: -(size) of an independent set\nevaluate(IS, [0, 1, 1, 0]) # Negative sample: 0\nfindbest(IS, BruteForce())  # solve the problem with brute force","category":"page"},{"location":"models/Factoring/#Prime-Factorization","page":"Prime Factorization","title":"Prime Factorization","text":"","category":"section"},{"location":"models/Factoring/#Problem-Definition","page":"Prime Factorization","title":"Problem Definition","text":"","category":"section"},{"location":"models/Factoring/","page":"Prime Factorization","title":"Prime Factorization","text":"Prime Factorization(Factoring)  is to decompose a number m into its prime factors p and q, denoted as m = p times q. ","category":"page"},{"location":"models/Factoring/#Interfaces","page":"Prime Factorization","title":"Interfaces","text":"","category":"section"},{"location":"models/Factoring/","page":"Prime Factorization","title":"Prime Factorization","text":"To initialize a Factoring, we need to specify the number to be factored(input) and the number of bits of the factors(m and n).","category":"page"},{"location":"models/Factoring/","page":"Prime Factorization","title":"Prime Factorization","text":"using ProblemReductions\n\nfactoring = Factoring(2,2,6)","category":"page"},{"location":"models/Factoring/","page":"Prime Factorization","title":"Prime Factorization","text":"Here, the two 2 is the factors' bit size and 6 is the number to be factored. 6 is 110 in binary so its factors should be 2-bits number.","category":"page"},{"location":"models/Factoring/","page":"Prime Factorization","title":"Prime Factorization","text":"Functions variables,flavors and evaluate are implemented for Factoring model. ","category":"page"},{"location":"models/Factoring/","page":"Prime Factorization","title":"Prime Factorization","text":"variables(factoring) # return the sum of factors' bit size\n\nflavors(factoring) \n\nevaluate(factoring,[0,1,1,1]) # 01 -> 2, 11 -> 3","category":"page"},{"location":"models/Factoring/","page":"Prime Factorization","title":"Prime Factorization","text":"note: Note\nevaluate function return 0 if the config is a correct factorization and 1 otherwise.","category":"page"},{"location":"models/Satisfiability/#Satisfiability","page":"Satisfiability","title":"Satisfiability","text":"","category":"section"},{"location":"models/Satisfiability/#Problem-Definition","page":"Satisfiability","title":"Problem Definition","text":"","category":"section"},{"location":"models/Satisfiability/","page":"Satisfiability","title":"Satisfiability","text":"Satisfiability (also called SAT) problem is to find the boolean assignment that satisfies a Conjunctive Normal Form (CNF). A tipical CNF would look like:","category":"page"},{"location":"models/Satisfiability/","page":"Satisfiability","title":"Satisfiability","text":"left(l_11 vee ldots vee l_1 n_1right) wedge ldots wedgeleft(l_m 1 vee ldots vee l_m n_mright)","category":"page"},{"location":"models/Satisfiability/","page":"Satisfiability","title":"Satisfiability","text":"where literals are joint by vee to form clauses and clauses are joint by wedge to form a CNF.","category":"page"},{"location":"models/Satisfiability/","page":"Satisfiability","title":"Satisfiability","text":"We should note that all the SAT problem problem can be reduced to the 3-SAT problem and it can be proved that 3-SAT is NP-complete.","category":"page"},{"location":"models/Satisfiability/#Interfaces","page":"Satisfiability","title":"Interfaces","text":"","category":"section"},{"location":"models/Satisfiability/","page":"Satisfiability","title":"Satisfiability","text":"To define an Satisfiability problem, we need to construct boolean variables, clauses, CNF.","category":"page"},{"location":"models/Satisfiability/","page":"Satisfiability","title":"Satisfiability","text":"using ProblemReductions\nbv1 = BoolVar(\"x\")\nbv2 = BoolVar(\"y\")\nbv3 = BoolVar(\"z\", true)    \nclause1 = CNFClause([bv1, bv2, bv3])\nclause2 = CNFClause([BoolVar(\"w\"), bv1, BoolVar(\"x\", true)])\ncnf_test = CNF([clause1, clause2])\nsat_test = Satisfiability(cnf_test)","category":"page"},{"location":"models/Satisfiability/","page":"Satisfiability","title":"Satisfiability","text":"Besides, the required functions, variables, flavors, and evaluate, and optional functions, findbest, are implemented for the Satisfiability problem.","category":"page"},{"location":"models/Satisfiability/","page":"Satisfiability","title":"Satisfiability","text":"variables(sat_test)  # degrees of freedom\nflavors(sat_test)  # flavors of the literals\nevaluate(sat_test, [1, 1, 1, 1]) # Positive sample\nevaluate(sat_test, [0, 0, 1, 0]) # Negative sample\nfindbest(sat_test, BruteForce())  # solve the problem with brute force","category":"page"},{"location":"models/Satisfiability/#Relation-with-the-Circuit-SAT","page":"Satisfiability","title":"Relation with the Circuit SAT","text":"","category":"section"},{"location":"models/Satisfiability/","page":"Satisfiability","title":"Satisfiability","text":"The circuit SAT can include other boolean expression beyond CNF such as Disjunctive Normal Form (DNF). However, all the boolean expressions can be generally transformed to CNF, so the circuit SAT is \"equivalent\" with SAT.","category":"page"},{"location":"generated/Ising/","page":"Solving Factoring problem with Ising machine","title":"Solving Factoring problem with Ising machine","text":"EditURL = \"../../../examples/Ising.jl\"","category":"page"},{"location":"generated/Ising/#Solving-Factoring-problem-with-Ising-machine","page":"Solving Factoring problem with Ising machine","title":"Solving Factoring problem with Ising machine","text":"","category":"section"},{"location":"generated/Ising/#Introduction","page":"Solving Factoring problem with Ising machine","title":"Introduction","text":"","category":"section"},{"location":"generated/Ising/","page":"Solving Factoring problem with Ising machine","title":"Solving Factoring problem with Ising machine","text":"Ising machines are powerful tools for solving SpinGlass problem. Given that many NP problems can be reduced to SpinGlass, it's possible to solve these NP problems with Ising machines. Among these problems, the Factoring problem is one of the most important problems and it's the basis of RSA encryption system for its practical hardness.","category":"page"},{"location":"generated/Ising/","page":"Solving Factoring problem with Ising machine","title":"Solving Factoring problem with Ising machine","text":"Therefore, solving Factoring problem with Ising machine is a significant task. In this example, we will show how to reduce the Factoring problem to SpinGlass with ProblemReductions.jl and solve it with an Ising machine solver GenericTensorNetworks.jl","category":"page"},{"location":"generated/Ising/#Factoring-SpinGlass-Ising-machine","page":"Solving Factoring problem with Ising machine","title":"Factoring -> SpinGlass -> Ising machine","text":"","category":"section"},{"location":"generated/Ising/","page":"Solving Factoring problem with Ising machine","title":"Solving Factoring problem with Ising machine","text":"Consider a simple Factoring problem: 6 = p times q, we need to figure out the prime factors of 6. In our package, the Factoring problem is modeling under binary representation and when we initialize an instance, we need to offer the information of the number of bits for the two factors. Here, since 6 is a 3 bit number, the number of bits for the two factors are both 2.","category":"page"},{"location":"generated/Ising/","page":"Solving Factoring problem with Ising machine","title":"Solving Factoring problem with Ising machine","text":"Run the following code in Julia REPL:","category":"page"},{"location":"generated/Ising/","page":"Solving Factoring problem with Ising machine","title":"Solving Factoring problem with Ising machine","text":"using ProblemReductions\nfactoring = Factoring(2, 2, 6) # initialize the Factoring problem","category":"page"},{"location":"generated/Ising/","page":"Solving Factoring problem with Ising machine","title":"Solving Factoring problem with Ising machine","text":"Using reduction_graph and reduction_paths, we could obtain the way to reduce Factoring to SpinGlass.","category":"page"},{"location":"generated/Ising/","page":"Solving Factoring problem with Ising machine","title":"Solving Factoring problem with Ising machine","text":"g = reduction_graph()\npaths = reduction_paths(g,Factoring,SpinGlass)","category":"page"},{"location":"generated/Ising/","page":"Solving Factoring problem with Ising machine","title":"Solving Factoring problem with Ising machine","text":"The input of reduction_paths is the reduction graph and the types of source and target problems. And the output is a nested vector, each element of the outer vector is a path from source to target problem.","category":"page"},{"location":"generated/Ising/","page":"Solving Factoring problem with Ising machine","title":"Solving Factoring problem with Ising machine","text":"Then we could use implement_reduction_path to obtain the corresponding SpinGlass problem.","category":"page"},{"location":"generated/Ising/","page":"Solving Factoring problem with Ising machine","title":"Solving Factoring problem with Ising machine","text":"reduction_result = implement_reduction_path(paths[1], factoring)\ntarget = target_problem(reduction_result)","category":"page"},{"location":"generated/Ising/","page":"Solving Factoring problem with Ising machine","title":"Solving Factoring problem with Ising machine","text":"Note that the output of implement_reduction_path is a AbstractReductionResult, which contains the target problem and reduction information. So we need to extract the target problem by target_problem function.","category":"page"},{"location":"generated/Ising/","page":"Solving Factoring problem with Ising machine","title":"Solving Factoring problem with Ising machine","text":"import GenericTensorNetworks # import Ising machine solver\ngtn_problem = GenericTensorNetworks.SpinGlass(\n                  target.graph.n,\n                  target.graph.edges,\n                  target.weights\n                )\nresult = GenericTensorNetworks.solve(\n                    GenericTensorNetworks.GenericTensorNetwork(gtn_problem),\n                    GenericTensorNetworks.SingleConfigMin()\n                  )[]","category":"page"},{"location":"generated/Ising/","page":"Solving Factoring problem with Ising machine","title":"Solving Factoring problem with Ising machine","text":"Here we use GenericTensorNetworks.jl to solve the SpinGlass problem and obtain the result, we need to extract the solution for source problem from the result.","category":"page"},{"location":"generated/Ising/","page":"Solving Factoring problem with Ising machine","title":"Solving Factoring problem with Ising machine","text":"extract_solution(reduction_result, 1 .- 2 .* Int.(GenericTensorNetworks.read_config(result)))","category":"page"},{"location":"generated/Ising/","page":"Solving Factoring problem with Ising machine","title":"Solving Factoring problem with Ising machine","text":"The result is 01 and 11, decimally 2 and 3, which yields the correct factors of 6.","category":"page"},{"location":"generated/Ising/#Conclusion","page":"Solving Factoring problem with Ising machine","title":"Conclusion","text":"","category":"section"},{"location":"generated/Ising/","page":"Solving Factoring problem with Ising machine","title":"Solving Factoring problem with Ising machine","text":"In this example, we show how to reduce Factoring problem to SpinGlass and solve it with Ising machine solver. This shows the power of ProblemReductions.jl in helping Problem Reduction.","category":"page"},{"location":"generated/Ising/","page":"Solving Factoring problem with Ising machine","title":"Solving Factoring problem with Ising machine","text":"For your convenience, here is how to use ProblemReductions.jl to reduce source problem to target problem:","category":"page"},{"location":"generated/Ising/","page":"Solving Factoring problem with Ising machine","title":"Solving Factoring problem with Ising machine","text":"Initialize the source problem source = SourceProblem(...), ... is the parameters of the source problem.\nObtain the reduction paths paths = reduction_paths(reduction_graph(), SourceProblem, TargetProblem).\nImplement the reduction path reduction_result = implement_reduction_path(paths[1], source).\nExtract the target problem target = target_problem(reduction_result).","category":"page"},{"location":"generated/Ising/","page":"Solving Factoring problem with Ising machine","title":"Solving Factoring problem with Ising machine","text":"","category":"page"},{"location":"generated/Ising/","page":"Solving Factoring problem with Ising machine","title":"Solving Factoring problem with Ising machine","text":"This page was generated using Literate.jl.","category":"page"},{"location":"models/Coloring/#Vertex-Coloring","page":"Vertex Coloring","title":"Vertex Coloring","text":"","category":"section"},{"location":"models/Coloring/#Problem-Definition","page":"Vertex Coloring","title":"Problem Definition","text":"","category":"section"},{"location":"models/Coloring/","page":"Vertex Coloring","title":"Vertex Coloring","text":"The Vertex Coloring (Coloring) problem is defined on a simple graph. Given k kinds of colors, we need to determine whether we can color all vertices on the graph such that no two adjacent vertices share the same color.","category":"page"},{"location":"models/Coloring/#Interfaces","page":"Vertex Coloring","title":"Interfaces","text":"","category":"section"},{"location":"models/Coloring/","page":"Vertex Coloring","title":"Vertex Coloring","text":"To initialize a Coloring problem, we need to first define a simple graph and decide the number of colors.","category":"page"},{"location":"models/Coloring/","page":"Vertex Coloring","title":"Vertex Coloring","text":"using ProblemReductions, Graphs\ng = smallgraph(:petersen) # define a simple graph, petersen as example\n\ncoloring = Coloring{3}(g)","category":"page"},{"location":"models/Coloring/","page":"Vertex Coloring","title":"Vertex Coloring","text":"We create a petersen graph and take 3 colors here to initialize a Coloring Problem. ","category":"page"},{"location":"models/Coloring/","page":"Vertex Coloring","title":"Vertex Coloring","text":"Functions variables, flavors, num_flavors, parameters and set_parameters are implemented for Coloring model. ","category":"page"},{"location":"models/Coloring/","page":"Vertex Coloring","title":"Vertex Coloring","text":"variables(coloring)\nflavors(coloring)","category":"page"},{"location":"models/Coloring/","page":"Vertex Coloring","title":"Vertex Coloring","text":"Also, evaluate and is_vertex_coloring is also implemented.","category":"page"},{"location":"models/Coloring/","page":"Vertex Coloring","title":"Vertex Coloring","text":"is_vertex_coloring(coloring.graph,[1,2,3,1,3,2,1,2,3,1]) #random assignment","category":"page"},{"location":"models/MaxCut/#Max-Cut","page":"Max Cut","title":"Max Cut","text":"","category":"section"},{"location":"models/MaxCut/#Problem-Definition","page":"Max Cut","title":"Problem Definition","text":"","category":"section"},{"location":"models/MaxCut/","page":"Max Cut","title":"Max Cut","text":"Max Cut problem is defined on weighted graphs. The goal is to find a partition of the vertices into two sets such that the sum of the weights of the edges between the two sets is maximized.","category":"page"},{"location":"models/MaxCut/#Interfaces","page":"Max Cut","title":"Interfaces","text":"","category":"section"},{"location":"models/MaxCut/","page":"Max Cut","title":"Max Cut","text":"To initialize a MaxCut, we need to specify the graph and the weights of the edges.","category":"page"},{"location":"models/MaxCut/","page":"Max Cut","title":"Max Cut","text":"using ProblemReductions, Graphs\ng = SimpleGraph(3)\nfor (i,j) in [(1,2),(1,3),(2,3)]\n    add_edge!(g,i,j)\nend # Add edges on the graph\nmaxcut = MaxCut(g,[1,2,3]) # specify the weights of the edges","category":"page"},{"location":"models/MaxCut/","page":"Max Cut","title":"Max Cut","text":"Here the graph is a simple graph with 3 vertices and 3 edges. The weights of the edges are [1,2,3].","category":"page"},{"location":"models/MaxCut/","page":"Max Cut","title":"Max Cut","text":"Required functions and optional functions: set_parameters, num_variables are implemented for this model.","category":"page"},{"location":"models/MaxCut/","page":"Max Cut","title":"Max Cut","text":"mc = set_parameters(maxcut, [2,1,3]) # set the weights and get a new instance\nnum_variables(maxcut) # return the number of vertices","category":"page"},{"location":"ref/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"ref/","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"ref/","page":"Reference","title":"Reference","text":"Modules = [ProblemReductions]","category":"page"},{"location":"ref/#ProblemReductions.AbstractProblem","page":"Reference","title":"ProblemReductions.AbstractProblem","text":"AbstractProblem\n\nThe abstract base type of computational problems.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.AbstractReductionResult","page":"Reference","title":"ProblemReductions.AbstractReductionResult","text":"abstract type AbstractReductionResult\n\nThe base type for a reduction result.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.BoolVar","page":"Reference","title":"ProblemReductions.BoolVar","text":"BoolVar{T}\nBoolVar(name, neg)\n\nBoolean variable for constructing CNF clauses.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.BruteForce","page":"Reference","title":"ProblemReductions.BruteForce","text":"struct BruteForce\n\nA brute force method to find the best configuration of a problem.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.CNF","page":"Reference","title":"ProblemReductions.CNF","text":"CNF{T}\nCNF(clauses)\n\nBoolean expression in conjunctive normal form. clauses is a vector of CNFClause, if and only if all clauses are satisfied, this CNF is satisfied.\n\nExample\n\nUnder development\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.CNFClause","page":"Reference","title":"ProblemReductions.CNFClause","text":"CNFClause{T}\nCNFClause(vars)\n\nA clause in CNF, its value is the logical or of vars, where vars is a vector of BoolVar.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.Circuit","page":"Reference","title":"ProblemReductions.Circuit","text":"struct Circuit\n\nA circuit expression is a sequence of assignments.\n\nFields\n\nexprs::Vector{Assignment}: The assignments in the circuit.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.CircuitSAT","page":"Reference","title":"ProblemReductions.CircuitSAT","text":"struct CircuitSAT <: AbstractProblem\n\nCircuit satisfiability problem, where the goal is to find an assignment that satisfies the circuit.\n\nFields\n\ncircuit::Circuit: The circuit expression in SSA form.\nsymbols::Vector{Symbol}: The variables in the circuit.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.Coloring","page":"Reference","title":"ProblemReductions.Coloring","text":"struct Coloring{K, WT<:(AbstractVector)} <: AbstractProblem\n\nColoring{K}(graph; weights=UnitWeight(nv(graph)))\n\nThe Vertex Coloring problem.\n\nPositional arguments\n\ngraph is the problem graph.\nweights are associated with the edges of the graph, default to UnitWeight(ne(graph)).\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.ConcatenatedReduction","page":"Reference","title":"ProblemReductions.ConcatenatedReduction","text":"struct ConcatenatedReduction\n\nA sequence of reductions.\n\nFields\n\nsequence::Vector{Any}: The sequence of reductions.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.DominatingSet","page":"Reference","title":"ProblemReductions.DominatingSet","text":"struct DominatingSet{GT<:Graphs.AbstractGraph, WT<:(AbstractVector)} <: AbstractProblem\n\nDominatingSet(graph::AbstractGraph, weights::AbstractVector=UnitWeight(ne(graph))) -> DominatingSet\n\nRepresents the dominating set problem.\n\nPositional arguments\n\ngraph is the problem graph.\nweights::AbstractVector: Weights associated with the vertices of the graph. Defaults to UnitWeight(nv(graph)).\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.Factoring","page":"Reference","title":"ProblemReductions.Factoring","text":"Factoring <: AbstractProblem\n\nFactoring problem. Given input, find its two prime factors, \n\nFields\n\nm::Int64\nn::Int64\ninput::Int64\n\nwhere m is the number of bits for the first number, n is the number of bits for the second number, and input is the number to factorize.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.GridGraph","page":"Reference","title":"ProblemReductions.GridGraph","text":"struct GridGraph <: Graphs.AbstractGraph{Int64}\n\nA grid graph is a graph in which the vertices are arranged in a grid and two vertices are connected by an edge if and only if they are adjacent in the grid.\n\nFields\n\ngrid::BitMatrix: a matrix of booleans, where true indicates the presence of an edge.\nradius::Float64: the radius of the unit disk\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.HyperGraph","page":"Reference","title":"ProblemReductions.HyperGraph","text":"struct HyperGraph <: Graphs.AbstractGraph{Int64}\n\nA hypergraph is a generalization of a graph in which an edge can connect any number of vertices.\n\nFields\n\nn::Int: the number of vertices\nedges::Vector{Vector{Int}}: a vector of vectors of integers, where each vector represents a hyperedge connecting the vertices with the corresponding indices.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.IndependentSet","page":"Reference","title":"ProblemReductions.IndependentSet","text":"struct IndependentSet{GT<:Graphs.AbstractGraph, WT<:(AbstractVector)} <: AbstractProblem\n\nIndependentSet(graph::AbstractGraph, weights::AbstractVector=UnitWeight(nv(graph))) -> IndependentSet\n\nRepresents the independent set problem in graph theory.\n\nPositional arguments\n\ngraph::AbstractGraph: The problem graph.\nweights::AbstractVector: Weights associated with the vertices of the graph. Defaults to UnitWeight(nv(graph)).\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.KSatisfiability","page":"Reference","title":"ProblemReductions.KSatisfiability","text":"struct KSatisfiability{K, T} <: ProblemReductions.AbstractSatisfiabilityProblem{T}\n\nThe satisfiability problem for k-SAT, where the goal is to find an assignment that satisfies the CNF.\n\nFields\n\nvariables::Vector{T}: The variables in the CNF.\ncnf::CNF{T}: The CNF expression.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.LogicGadget","page":"Reference","title":"ProblemReductions.LogicGadget","text":"struct LogicGadget{PT<:AbstractProblem}\n\nThe logic gadget defined on an computational model.\n\nFields\n\nproblem::PT: the computational model, e.g., SpinGlass.\ninputs::Vector{Int}: the input variables.\noutputs::Vector{Int}: the output variables.\n\nReferences\n\nWhat are the cost function for NAND and NOR gates?\nNguyen, M.-T., Liu, J.-G., Wurtz, J., Lukin, M.D., Wang, S.-T., Pichler, H., 2023. Quantum Optimization with Arbitrary Connectivity Using Rydberg Atom Arrays. PRX Quantum 4, 010316.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.Matching","page":"Reference","title":"ProblemReductions.Matching","text":"struct Matching{WT<:Union{UnitWeight, Vector}} <: AbstractProblem\n\nThe Vertex matching problem.\n\nPositional arguments\n\ngraph is the problem graph.\nweights are associated with the edges of the graph.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.MaxCut","page":"Reference","title":"ProblemReductions.MaxCut","text":"struct MaxCut{WT<:(AbstractVector)} <: AbstractProblem\n\nThe cutting problem.\n\nIn this problem, we would like to find the cut of the graph that maximizes the sum of the \n\nweights of the edges that are cut.\n\nPositional arguments\n\ngraph is the problem graph.\nweights are associated with the edges of the graph. We have ensure that the weights are in the same order as the edges in edges(graph).\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.MaximalIS","page":"Reference","title":"ProblemReductions.MaximalIS","text":"struct MaximalIS{WT<:Union{UnitWeight, Vector}} <: AbstractProblem\n\nThe [maximal independent set]problem.  In the constructor, weights are the weights of vertices.\n\nPositional arguments\n\ngraph is the problem graph.\nweights are associated with the vertices of the graph.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.PaintShop","page":"Reference","title":"ProblemReductions.PaintShop","text":"struct PaintShop{LT} <: AbstractProblem\n\nThe binary paint shop problem.\n\nPositional arguments\n\nsequence is a vector of symbols, each symbol is associated with a color.\nisfirst is a vector of boolean numbers, indicating whether the symbol is the first appearance in the sequence.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.QUBO","page":"Reference","title":"ProblemReductions.QUBO","text":"struct QUBO{T<:Real} <: AbstractProblem\n\nThe quadratic unconstrained binary optimization.\n\nE = sum_ij Q_ij x_i x_j\n\nwhere x_i \\in \\{0, 1\\}.\n\nArguments\n\nmatrix::AbstractMatrix: the matrix Q of the QUBO problem.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.ReductionCircuitToSpinGlass","page":"Reference","title":"ProblemReductions.ReductionCircuitToSpinGlass","text":"struct ReductionCircuitToSpinGlass{GT, T} <: AbstractReductionResult\n\nThe reduction result of a circuit to a spin glass problem.\n\nFields\n\nnum_source_vars::Int: the number of variables in the source circuit.\nspinglass::SpinGlass{GT, T}: the spin glass problem.\nvariables::Vector{Int}: the variables in the spin glass problem.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.ReductionFactoringToSat","page":"Reference","title":"ProblemReductions.ReductionFactoringToSat","text":"struct ReductionFactoringToSat <: AbstractReductionResult\n\nThe reduction result of a  factoring problem to a CircuitSAT problem.\n\nFields\n\ncircuit::CircuitSAT: the CircuitSAT problem.\np::Vector{Int}: the first number to multiply (store bit locations)\nq::Vector{Int}: the second number to multiply.\nm::Vector{Int}: the result of the multiplication.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.ReductionGraph","page":"Reference","title":"ProblemReductions.ReductionGraph","text":"ReductionGraph\n\nA directed graph representing the reduction paths between different problems. A node represents a problem type, and an edge represents a reduction rule from one problem type to another.\n\nFields\n\ngraph::Graphs.SimpleGraphs.SimpleDiGraph{Int64}\nnodes::Vector{Any}\nmethod_table::Dict{Pair{Int64, Int64}, Method}\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.ReductionIndependentSetToSetPacking","page":"Reference","title":"ProblemReductions.ReductionIndependentSetToSetPacking","text":"struct ReductionIndependentSetToSetPacking{ET} <: AbstractReductionResult\n\nThe reduction result of an Independent Set problem to a Set Packing problem.\n\nFields\n\ntarget::SetPacking\nvertices_list::Vector{Int64}\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.ReductionMaxCutToSpinGlass","page":"Reference","title":"ProblemReductions.ReductionMaxCutToSpinGlass","text":"struct ReductionMaxCutToSpinGlass{GT, T} <: AbstractReductionResult\n\nThe reduction result of a maxcut to a spin glass problem.\n\nFields\n\nspinglass::SpinGlass{GT, T}: the spin glass problem.\n\nWe only consider a simple reduction from MaxCut to SpinGlass(the graph must be SimpleGraph).\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.ReductionQUBOToSpinGlass","page":"Reference","title":"ProblemReductions.ReductionQUBOToSpinGlass","text":"struct ReductionQUBOToSpinGlass{GT, T} <: AbstractReductionResult\n\nThe reduction result of a qubo to a spin glass problem.\n\nFields\n\nspinglass::SpinGlass{GT, T}: the spin glass problem.\n\nWe only consider a simple reduction from QUBO to SpinGlass(the graph must be SimpleGraph).\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.ReductionSATTo3SAT","page":"Reference","title":"ProblemReductions.ReductionSATTo3SAT","text":"The reduction result of a general SAT problem to a 3-SAT problem.\n\nFields\n\nsat_source::Satisfiability{GT, T}: the source general SAT problem.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.ReductionSATToCircuit","page":"Reference","title":"ProblemReductions.ReductionSATToCircuit","text":"struct ReductionSATToCircuit <: AbstractReductionResult\n\nThe reduction result of an SAT problem o a Circuit SAT problem.\n\nFields\n\ntarget::CircuitSAT: the target problem.\ntarget::CircuitSAT\nsat_symbols::Vector{Symbol}\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.ReductionSATToDominatingSet","page":"Reference","title":"ProblemReductions.ReductionSATToDominatingSet","text":"struct ReductionSATToDominatingSet{GT<:Graphs.AbstractGraph} <: AbstractReductionResult\n\nThe reduction result of a general SAT problem to an Dominating Set problem.\n\nFields\n\ntarget::DominatingSet\nnum_literals::Int64\nnum_clauses::Int64\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.ReductionSATToIndependentSet","page":"Reference","title":"ProblemReductions.ReductionSATToIndependentSet","text":"struct ReductionSATToIndependentSet{T, GT<:Graphs.AbstractGraph, WT<:(AbstractVector)} <: AbstractReductionResult\n\nThe reduction result of a general SAT problem to an Independent Set problem.\n\nFields\n\ntarget::IndependentSet\nliterals::Array{BoolVar{T}, 1} where T\nsource_variables::Vector\nnum_clauses::Int64\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.ReductionSatToColoring","page":"Reference","title":"ProblemReductions.ReductionSatToColoring","text":"struct ReductionSatToColoring{K, T, WT<:(AbstractVector)} <: AbstractReductionResult\n\nThe reduction result of a Sat problem to a Coloring problem.\n\nFields\n\nColoring{K, WT<:AbstractVector}: the coloring problem, where K is the number of colors and WT is the weights type. \nvarlabel, used to filter extra variables\n\nNote: The coloring problem is a 3 coloring problem, in which a auxiliary color is used Auxiliary color => 2.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.ReductionSpinGlassToMaxCut","page":"Reference","title":"ProblemReductions.ReductionSpinGlassToMaxCut","text":"struct ReductionSpinGlassToMaxCut{WT} <: AbstractReductionResult\n\nThe reduction result of a spin glass to a maxcut problem.\n\nFields\n\nmaxcut::MaxCut{WT}: the MaxCut problem.\nancilla::Int: the ancilla vertex.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.ReductionSpinGlassToQUBO","page":"Reference","title":"ProblemReductions.ReductionSpinGlassToQUBO","text":"struct ReductionSpinGlassToQUBO{WT} <: AbstractReductionResult\n\nThe reduction result of a spin glass to a QUBO problem.\n\nFields\n\nqubo::QUBO{WT}: the QUBO problem.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.ReductionVertexCoveringToSetCovering","page":"Reference","title":"ProblemReductions.ReductionVertexCoveringToSetCovering","text":"struct ReductionVertexCoveringToSetCovering{ET, WT<:(AbstractVector)} <: AbstractReductionResult\n\nThe reduction result of a vertex covering to a set covering problem.\n\nFields\n\nsetcovering::SetCovering{ET,WT}: the set covering problem, where ET is the sets type and WT is the weights type.\nedgelabel: map each edge to a number in order to identify the edge (otherwise the vector would be cluttering)\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.Satisfiability","page":"Reference","title":"ProblemReductions.Satisfiability","text":"struct Satisfiability{T} <: ProblemReductions.AbstractSatisfiabilityProblem{T}\n\nThe satisfiability problem.\n\nFields\n\ncnf is a conjunctive normal form (CNF) for specifying the satisfiability problems.\nweights are associated with clauses.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.SetCovering","page":"Reference","title":"ProblemReductions.SetCovering","text":"struct SetCovering{ET, WT<:(AbstractVector)} <: AbstractProblem\n\nThe Set Covering problem is defined as follow: given a universe of elements and a collection of subsets of the universe, each set is associated with a weight.  The goal is to find a subset of sets that covers all the elements with the minimum total weight.\n\nPositional arguments\n\nelements is a vector of elements in the universe.\nsets is a vector of vectors, a collection of subsets of universe , each set is associated with a weight specified in weights.\nweights are associated with sets.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.SetPacking","page":"Reference","title":"ProblemReductions.SetPacking","text":"struct SetPacking{ET, WT<:(AbstractVector)} <: AbstractProblem\n\nSetPacking(elements::AbstractVector, sets::AbstractVector, weights::AbstractVector=UnitWeight(length(sets))) -> SetPacking\n\nThe set packing problem is to find a set of sets, where each set is pairwise disjoint from each other.\n\nPositional arguments\n\nelements is a vector of elements in the universe.\nsets is a vector of vectors, each set is associated with a weight specified in weights.\nweights are associated with sets. Defaults to UnitWeight(length(sets)).\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.SpinGlass","page":"Reference","title":"ProblemReductions.SpinGlass","text":"struct SpinGlass{GT<:Graphs.AbstractGraph, WT<:(AbstractVector)} <: AbstractProblem\n\nSpinGlass(graph::AbstractGraph, J, h=zeros(nv(graph)))\n\nThe spin-glass problem.\n\nPositional arguments\n\ngraph is a graph object.\nweights are associated with the edges.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.StaticBitVector","page":"Reference","title":"ProblemReductions.StaticBitVector","text":"StaticBitVector{N,C} = StaticElementVector{N,1,C}\nStaticBitVector(x::AbstractVector)\n\nExamples\n\njulia> sb = StaticBitVector([1,0,0,1,1])\n10011\n\njulia> sb[3]\n0x0000000000000000\n\njulia> collect(Int, sb)\n5-element Vector{Int64}:\n 1\n 0\n 0\n 1\n 1\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.StaticElementVector","page":"Reference","title":"ProblemReductions.StaticElementVector","text":"StaticElementVector{N,S,C}\nStaticElementVector(nflavor::Int, x::AbstractVector)\n\nN is the length of vector, C is the size of storage in unit of UInt64, S is the stride defined as the log2(# of flavors). When the number of flavors is 2, it is a StaticBitVector.\n\nFields\n\ndata is a tuple of UInt64 for storing the configuration of static elements.\n\nExamples\n\njulia> ev = StaticElementVector(3, [1,2,0,1,2])\n12012\n\njulia> ev[2]\n0x0000000000000002\n\njulia> collect(Int, ev)\n5-element Vector{Int64}:\n 1\n 2\n 0\n 1\n 2\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.TruthTable","page":"Reference","title":"ProblemReductions.TruthTable","text":"struct TruthTable{N, T}\n\nThe truth table.\n\nFields\n\ninputs::Vector{T}: The input values.\noutputs::Vector{T}: The output values.\nvalues::Vector{BitStr{N, Int}}: The truth table values.\n\nExamples\n\njulia> tt = TruthTable(['a', 'b'], ['c'], [bit\"0\", bit\"0\", bit\"0\", bit\"1\"])\n┌───┬───┬───┐\n│ a │ b │ c │\n├───┼───┼───┤\n│ 0 │ 0 │ 0 │\n│ 1 │ 0 │ 0 │\n│ 0 │ 1 │ 0 │\n│ 1 │ 1 │ 1 │\n└───┴───┴───┘\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.UnitDiskGraph","page":"Reference","title":"ProblemReductions.UnitDiskGraph","text":"struct UnitDiskGraph{D, T} <: Graphs.AbstractGraph{Int64}\n\nA unit disk graph is a graph in which the vertices are points in a plane and two vertices are connected by an edge if and only if the Euclidean distance between them is at most a given radius.\n\nFields\n\nn::Int: the number of vertices\nlocations::Vector{NTuple{D, T}}: the locations of the vertices\nradius::T: the radius of the unit disk\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.VertexCovering","page":"Reference","title":"ProblemReductions.VertexCovering","text":"struct VertexCovering{WT<:(AbstractVector)} <: AbstractProblem\n\nVertex covering is a problem that seeks to find a minimum set of vertices that cover all edges in a graph.\n\nPositional arguments\n\ngraph is a graph object.\nweights are associated with the vertices of the graph, default to UnitWeight(nv(graph)).\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.:¬-Union{Tuple{BoolVar{T}}, Tuple{T}} where T","page":"Reference","title":"ProblemReductions.:¬","text":"¬(var::BoolVar)\n\nNegation of a boolean variables of type BoolVar.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.:∧-Union{Tuple{T}, Tuple{CNFClause{T}, Vararg{CNFClause{T}}}} where T","page":"Reference","title":"ProblemReductions.:∧","text":"∧(vars...)\n\nLogical and applied on CNFClause and CNF. Returns a new CNF.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.:∨-Union{Tuple{T}, Tuple{BoolVar{T}, Vararg{BoolVar{T}}}} where T","page":"Reference","title":"ProblemReductions.:∨","text":"∨(vars...)\n\nLogical or applied on BoolVar and CNFClause. Returns a CNFClause.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.configuration_space_size-Tuple{AbstractProblem}","page":"Reference","title":"ProblemReductions.configuration_space_size","text":"configuration_space_size(problem::AbstractProblem) -> Any\n\n\nReturn the log2 size of the configuration space of the problem.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.evaluate","page":"Reference","title":"ProblemReductions.evaluate","text":"evaluate(problem::AbstractProblem, config) -> Real\n\nEvaluate the energy of the problem given the configuration config. The lower the energy, the better the configuration.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.evaluate-Tuple{Coloring, Any}","page":"Reference","title":"ProblemReductions.evaluate","text":"evaluate(c::Coloring, config)\n\nCompute the energy of the vertex coloring configuration config, the energy is the number of violated edges.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.evaluate-Tuple{DominatingSet, Any}","page":"Reference","title":"ProblemReductions.evaluate","text":"evaluate(c::DominatingSet, config)\n\nCount the number of vertices outside the dominating set and the neighbours of the dominating set.  When the number is zero, the configuration corresponds to a dominating set. \n\nIf the configuration is a dominating set return size(dominating set).\nIf the configuration is not a dominating set return nv(graph);\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.evaluate-Tuple{IndependentSet, Any}","page":"Reference","title":"ProblemReductions.evaluate","text":"evaluate(c::IndependentSet, config)\n\nCount the edges connecting the input 'config' (a subset of vertices).  If this number is zero, this 'config' corresponds to an Independent Set. Otherwise, these edges would violate the definition of independent set.\n\nIf the 'config' is an independent set, we return - (size(independent set));\nIf the 'config' is not an independent set, we return 0.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.evaluate-Tuple{Matching, Any}","page":"Reference","title":"ProblemReductions.evaluate","text":"evaluate(c::Matching, config)\nReturn Inf if the configuration is not a matching, otherwise return the sum of the weights of the edges in the matching.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.evaluate-Tuple{MaxCut, Any}","page":"Reference","title":"ProblemReductions.evaluate","text":"evaluate(c::MaxCut, config)\n\nCompute the cut weights for the vertex configuration config (an iterator). The energy is the  sum of the weights of the edges that are cut.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.evaluate-Tuple{MaximalIS, Any}","page":"Reference","title":"ProblemReductions.evaluate","text":"evaluate(c::MaximalIS, config)\nReturn the weights of the vertices that are not in the maximal independent set.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.evaluate-Tuple{PaintShop, Any}","page":"Reference","title":"ProblemReductions.evaluate","text":"evaluate(ps::PaintShop, config)\n\nReturns the number of color switches. For example, if the sequence is abaccb ,there are three variables, then the config should be [1,0,1] or [0,1,0]. Here [1,0,1] means you want the first color for a and c is red, and the first color for b is blue.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.evaluate-Tuple{SetPacking, Any}","page":"Reference","title":"ProblemReductions.evaluate","text":"evaluate(c::SetPacking, config)\n\nFirst step: We check if config (a vector of boolean numbers as the mask of sets) is a set packing of sets;\nSecond step: If it is a set packing, we return (size(set packing)); Otherwise, we return 0.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.evaluate-Tuple{VertexCovering, Any}","page":"Reference","title":"ProblemReductions.evaluate","text":"evaluate(c::VertexCovering, config)\n\nreturn the weights of edge that is not covered but return typemax(eltype(weights)) if the edge is not covered. config is a vector of boolean numbers.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.extract_multiple_solutions-Tuple{AbstractReductionResult, Any}","page":"Reference","title":"ProblemReductions.extract_multiple_solutions","text":"extract_multiple_solutions(reduction::AbstractReductionResult, solution_set)\n\nExtract multiple solutions together solution_set of the target problem to the original problem.\n\nArguments\n\nreduction: The reduction result.\nsolution_set: The set of multiple solutions of the target problem.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.extract_solution","page":"Reference","title":"ProblemReductions.extract_solution","text":"extract_solution(reduction::AbstractReductionResult, solution)\n\nExtract the solution solution of the target problem to the original problem.\n\nArguments\n\nreduction: The reduction result.\nsolution: The solution of the target problem.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.findbest","page":"Reference","title":"ProblemReductions.findbest","text":"findbest(problem::AbstractProblem, method) -> Vector\n\nFind the best configurations of the problem using the method.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.flavor_to_logical-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Reference","title":"ProblemReductions.flavor_to_logical","text":"flavor_to_logical(::Type{T}, flavor) -> T\n\nConvert the flavor to a logical value.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.flavors-Tuple{GT} where GT<:AbstractProblem","page":"Reference","title":"ProblemReductions.flavors","text":"flavors(::Type{<:AbstractProblem}) -> Vector\n\nReturns a vector of integers as the flavors (domain) of a degree of freedom.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.implement_reduction_path-Tuple{AbstractVector, AbstractProblem}","page":"Reference","title":"ProblemReductions.implement_reduction_path","text":"implement_reduction_path(rg::ReductionGraph, path::AbstractVector, problem::AbstractProblem)\n\nImplement a reduction path on a problem. Returns a ConcatenatedReduction instance.\n\nArguments\n\npath::AbstractVector: A sequence of problem types, each element is an AbstractProblem instance.\nproblem::AbstractProblem: The source problem, the type of which must be the same as the first node in the path.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.is_matching-Tuple{SimpleGraph, Any}","page":"Reference","title":"ProblemReductions.is_matching","text":"is_matching(graph::SimpleGraph, config)\n\nReturns true if config is a valid matching on graph, and false if a vertex is double matched. config is a vector of boolean variables, which has one to one correspondence with edges(graph).\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.is_maximal_independent_set-Tuple{SimpleGraph, Any}","page":"Reference","title":"ProblemReductions.is_maximal_independent_set","text":"is_maximal_independent_set(g::SimpleGraph, config)\n\nReturn true if config (a vector of boolean numbers as the mask of vertices) is a maximal independent set of graph g.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.is_set_covering-Tuple{SetCovering, Any}","page":"Reference","title":"ProblemReductions.is_set_covering","text":"is_set_covering(c::SetCovering, config)\n\nReturn true if config (a vector of boolean numbers as the mask of sets) is a set covering of sets.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.is_set_packing-Union{Tuple{ST}, Tuple{AbstractVector{ST}, Any}} where ST","page":"Reference","title":"ProblemReductions.is_set_packing","text":"is_set_packing(sets::AbstractVector, config)\n\nReturn true if config (a vector of boolean numbers as the mask of sets) is a set packing of sets.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.is_vertex_coloring-Tuple{SimpleGraph, Any}","page":"Reference","title":"ProblemReductions.is_vertex_coloring","text":"is_vertex_coloring(graph::SimpleGraph, config)\n\nReturns true if the coloring specified by config is a valid one, i.e. does not violate the contraints of vertices of an edges having different colors.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.is_vertex_covering-Tuple{SimpleGraph, Any}","page":"Reference","title":"ProblemReductions.is_vertex_covering","text":"is_vertex_covering(graph::SimpleGraph, config)\n\nreturn true if the vertex configuration config is a vertex covering of the graph. Our judgement is based on the fact that for each edge, at least one of its vertices is selected.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.num_flavors-Tuple{GT} where GT<:AbstractProblem","page":"Reference","title":"ProblemReductions.num_flavors","text":"num_flavors(::Type{<:AbstractProblem}) -> Int\n\nReturns the number of flavors (domain) of a degree of freedom.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.num_variables-Tuple{AbstractProblem}","page":"Reference","title":"ProblemReductions.num_variables","text":"num_variables(problem::AbstractProblem) -> Int\n\nThe number of variables in the computational problem.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.onehotv-Union{Tuple{C}, Tuple{S}, Tuple{N}, Tuple{Type{StaticElementVector{N, S, C}}, Any, Any}} where {N, S, C}","page":"Reference","title":"ProblemReductions.onehotv","text":"onehotv(::Type{<:StaticElementVector}, i, v)\nonehotv(::Type{<:StaticBitVector, i)\n\nReturns a static element vector, with the value at location i being v (1 if not specified).\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.paint_shop_coloring_from_config-Union{Tuple{LT}, Tuple{PaintShop{LT}, Any}} where LT","page":"Reference","title":"ProblemReductions.paint_shop_coloring_from_config","text":"paint_shop_coloring_from_config(p::PaintShop, config)\n\nReturns a valid painting from the paint shop configuration (given by the configuration solvers). The config is a sequence of 0 and 1, where 0 means painting the first appearence of a car in red,  and 1 means painting the first appearence of a car in blue.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.parameter_type-Tuple{AbstractProblem}","page":"Reference","title":"ProblemReductions.parameter_type","text":"parameter_type(problem::AbstractProblem) -> Type\n\nThe data type of the parameters in the computational problem.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.parameters","page":"Reference","title":"ProblemReductions.parameters","text":"parameters(problem::AbstractProblem) -> Vector\n\nThe parameters of the computational problem.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.problem_size","page":"Reference","title":"ProblemReductions.problem_size","text":"problem_size(problem::AbstractProblem) -> NamedTuple\n\nThe size of the computational problem, which is problem dependent.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.problem_size-Tuple{SetCovering}","page":"Reference","title":"ProblemReductions.problem_size","text":"Defined as the number of sets.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.reduce_size-Union{Tuple{TA}, Tuple{Type{TA}, AbstractProblem}} where TA<:AbstractProblem","page":"Reference","title":"ProblemReductions.reduce_size","text":"reduce_size(::Type{T}, ::Type{S}, size)\n\nReturn the size of the target problem T after reducing the source problem S to T.\n\nnote: Note\nThe problem size measure is problem dependent. Please check problem_size for the problem size measure.\n\nArguments\n\nT: The target problem type.\nS: The source problem type.\nsize: The size of the source problem.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.reduceto","page":"Reference","title":"ProblemReductions.reduceto","text":"reduceto(::Type{TA}, x::AbstractProblem)\n\nReduce the problem x to a target problem of type TA. Returns an instance of AbstractReductionResult.\n\nArguments\n\nTA: The target problem type.\nx: The original problem.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.reduction_graph-Tuple{}","page":"Reference","title":"ProblemReductions.reduction_graph","text":" reduction_graph()\n\nReturns a ReductionGraph instance from the reduction rules defined with method reduceto.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.reduction_paths-Union{Tuple{S}, Tuple{T}, Tuple{Type{S}, Type{T}}} where {T<:AbstractProblem, S<:AbstractProblem}","page":"Reference","title":"ProblemReductions.reduction_paths","text":"reduction_paths([rg::ReductionGraph, ]S::Type, T::Type)\n\nFind all reduction paths from problem type S to problem type T. Returns a list of paths, where each path is a sequence of problem types.\n\nArguments\n\nrg::ReductionGraph: The reduction graph of type ReductionGraph.\nS::Type: The source problem type.\nT::Type: The target problem type.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.satisfiable-Union{Tuple{T}, Tuple{CNF{T}, AbstractDict{T}}} where T","page":"Reference","title":"ProblemReductions.satisfiable","text":"satisfiable(cnf::CNF, config::AbstractDict)\n\nReturns true if an assignment of variables satisfies a CNF.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.set_parameters","page":"Reference","title":"ProblemReductions.set_parameters","text":"set_parameters(problem::AbstractProblem, parameters) -> AbstractProblem\n\nChange the parameters for the problem and return a new problem instance.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.spinglass_energy-Tuple{AbstractVector{Vector{Int64}}, Any}","page":"Reference","title":"ProblemReductions.spinglass_energy","text":"spinglass_energy(g::SimpleGraph, config; J, h)\nspinglass_energy(cliques::AbstractVector{Vector{Int}}, config; weights)\n\nCompute the spin glass state energy for the vertex configuration config. In the configuration, the spin ↑ is mapped to configuration 0, while spin ↓ is mapped to configuration 1. Let G=(VE) be the input graph, the hamiltonian is\n\nH = sum_ij in E J_ij s_i s_j + sum_i in V h_i s_i\n\nwhere s_i in -1 1 stands for spin ↓ and spin ↑.\n\nIn the hypergraph case, the hamiltonian is\n\nH = sum_c in C w_c prod_i in c s_i\n\nwhere C is the set of cliques, and w_c is the weight of the clique c.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.spinglass_gadget-Tuple{Val{:arraymul}}","page":"Reference","title":"ProblemReductions.spinglass_gadget","text":"spinglass_gadget(::Val{:arraymul})\n\nThe array multiplier gadget.\n\n    s_{i+1,j-1}  p_i\n           \\     |\n        q_j ------------ q_j\n                 |\n    c_{i,j} ------------ c_{i-1,j}\n                 |     \\\n                 p_i     s_{i,j} \n\nvariables: pi, qj, pq, c{i-1,j}, s{i+1,j-1}, c{i,j}, s{i,j}\nconstraints: 2 * c{i,j} + s{i,j} = pi qj + c{i-1,j} + s{i+1,j-1}\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.target_problem","page":"Reference","title":"ProblemReductions.target_problem","text":"target_problem(res::AbstractReductionResult) -> AbstractProblem\n\nReturn the target problem of the reduction result.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.truth_table-Tuple{LogicGadget}","page":"Reference","title":"ProblemReductions.truth_table","text":"truth_table(ga::LogicGadget; variables=1:num_variables(ga.problem), solver=BruteForce())\n\nCompute the truth table of a logic gadget.\n\nArguments\n\nga::LogicGadget: the logic gadget.\n\nKeyword Arguments\n\nvariables::Vector{Int}: the variables to be displayed.\nsolver::AbstractSolver: the solver to be used.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.variables","page":"Reference","title":"ProblemReductions.variables","text":"variables(problem::AbstractProblem) -> Vector\n\nThe degrees of freedoms in the computational problem. e.g. for the maximum independent set problems, they are the indices of vertices: 1, 2, 3..., while for the max cut problem, they are the edges.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.@bools-Tuple{Vararg{Symbol}}","page":"Reference","title":"ProblemReductions.@bools","text":"@bools(syms::Symbol...)\n\nCreate some boolean variables of type BoolVar in current scope that can be used in create a CNF.\n\nExample\n\nUnder Development\n\n\n\n\n\n","category":"macro"},{"location":"ref/#ProblemReductions.@bv_str-Tuple{Any}","page":"Reference","title":"ProblemReductions.@bv_str","text":"Constructing a static bit vector.\n\n\n\n\n\n","category":"macro"},{"location":"ref/#ProblemReductions.@circuit-Tuple{Any}","page":"Reference","title":"ProblemReductions.@circuit","text":"@circuit circuit_expr\n\nConstruct a circuit expression from a block of assignments.\n\nExamples\n\njulia> @circuit begin\n        x = a ∨ b\n        y = x ∧ c\n       end\nCircuit:\n| x = ∨(a, b)\n| y = ∧(x, c)\n\n\n\n\n\n","category":"macro"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = ProblemReductions","category":"page"},{"location":"#ProblemReductions","page":"Home","title":"ProblemReductions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for ProblemReductions. This package is expected to be a tool for researchers to study the relationship between different computational hard problems. It defines a set of computational hard problems and provides a set of functions to reduce one problem to another. The package is designed to be extensible, so that users can easily add new reductions to the package.","category":"page"},{"location":"rules/#Problem-Reduction-Rules","page":"Problem Reduction Rules","title":"Problem Reduction Rules","text":"","category":"section"},{"location":"rules/","page":"Problem Reduction Rules","title":"Problem Reduction Rules","text":"A problem reduction rule is a function that reduces a problem to another problem. By solving the target problem, we can extract the solution to the original problem. The reduction rule is defined as a function that takes an instance of the original problem and returns an AbstractReductionResult instance of the target problem.","category":"page"},{"location":"rules/#Interfaces","page":"Problem Reduction Rules","title":"Interfaces","text":"","category":"section"},{"location":"rules/","page":"Problem Reduction Rules","title":"Problem Reduction Rules","text":"reduceto: Reduce the source problem to a target problem of a specific type. Returns an AbstractReductionResult instance, which contains the target problem.\ntarget_problem: Return the target problem of the reduction result.\nextract_solution: Extract the solution of the target problem to the original problem.","category":"page"},{"location":"rules/","page":"Problem Reduction Rules","title":"Problem Reduction Rules","text":"Optional functions include:","category":"page"},{"location":"rules/","page":"Problem Reduction Rules","title":"Problem Reduction Rules","text":"reduce_size: Infer the size of the target problem from the source problem size.","category":"page"},{"location":"models/CircuitSAT/#Circuit-Satisfaction","page":"Circuit Satisfaction","title":"Circuit Satisfaction","text":"","category":"section"},{"location":"models/CircuitSAT/#Problem-Definition","page":"Circuit Satisfaction","title":"Problem Definition","text":"","category":"section"},{"location":"models/CircuitSAT/","page":"Circuit Satisfaction","title":"Circuit Satisfaction","text":"A circuit can be defined with the @circuit macro as follows:","category":"page"},{"location":"models/CircuitSAT/","page":"Circuit Satisfaction","title":"Circuit Satisfaction","text":"using ProblemReductions\n\ncircuit = @circuit begin\n    c = x ∧ y\n    d = x ∨ (c ∧ ¬z)\nend","category":"page"},{"location":"models/CircuitSAT/","page":"Circuit Satisfaction","title":"Circuit Satisfaction","text":"The circuit can be converted to a CircuitSAT problem instance:","category":"page"},{"location":"models/CircuitSAT/","page":"Circuit Satisfaction","title":"Circuit Satisfaction","text":"sat = CircuitSAT(circuit)\nsat.symbols","category":"page"},{"location":"models/CircuitSAT/","page":"Circuit Satisfaction","title":"Circuit Satisfaction","text":"Note that the circuit is converted to the static single assignment (SSA) form, and the symbols are stored in the symbols field. The symbols are variables in the circuit to be assigned to true or false.","category":"page"},{"location":"models/CircuitSAT/#Interfaces","page":"Circuit Satisfaction","title":"Interfaces","text":"","category":"section"},{"location":"models/CircuitSAT/","page":"Circuit Satisfaction","title":"Circuit Satisfaction","text":"variables(sat)\nflavors(sat)","category":"page"},{"location":"models/CircuitSAT/","page":"Circuit Satisfaction","title":"Circuit Satisfaction","text":"The circuit can be evaluated with the evaluate function:","category":"page"},{"location":"models/CircuitSAT/","page":"Circuit Satisfaction","title":"Circuit Satisfaction","text":"evaluate(sat, [true, false, true, true, false, false, true])","category":"page"},{"location":"models/CircuitSAT/","page":"Circuit Satisfaction","title":"Circuit Satisfaction","text":"The return value is 0 if the assignment satisfies the circuit, otherwise, it is the number of unsatisfied clauses.","category":"page"},{"location":"models/CircuitSAT/","page":"Circuit Satisfaction","title":"Circuit Satisfaction","text":"note: Note\nevaluate funciton returns lower values for satisfiable assignments.","category":"page"},{"location":"models/CircuitSAT/","page":"Circuit Satisfaction","title":"Circuit Satisfaction","text":"To find all satisfying assignments, use the findbest function:","category":"page"},{"location":"models/CircuitSAT/","page":"Circuit Satisfaction","title":"Circuit Satisfaction","text":"findbest(sat, BruteForce())","category":"page"},{"location":"models/CircuitSAT/","page":"Circuit Satisfaction","title":"Circuit Satisfaction","text":"Here, the BruteForce solver is used to find the best assignment.","category":"page"}]
}
