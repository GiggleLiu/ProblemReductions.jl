var documenterSearchIndex = {"docs":
[{"location":"generated/Ising/","page":"Solving Factoring problem with Ising machine","title":"Solving Factoring problem with Ising machine","text":"EditURL = \"../../../examples/Ising.jl\"","category":"page"},{"location":"generated/Ising/#Solving-Factoring-problem-with-Ising-machine","page":"Solving Factoring problem with Ising machine","title":"Solving Factoring problem with Ising machine","text":"","category":"section"},{"location":"generated/Ising/#Introduction","page":"Solving Factoring problem with Ising machine","title":"Introduction","text":"","category":"section"},{"location":"generated/Ising/","page":"Solving Factoring problem with Ising machine","title":"Solving Factoring problem with Ising machine","text":"Ising machines are powerful tools for solving SpinGlass problem. Given that many NP problems can be reduced to SpinGlass, it's possible to solve these NP problems with Ising machines. Among these problems, the Factoring problem is one of the most important problems and it's the basis of RSA encryption system for its practical hardness.","category":"page"},{"location":"generated/Ising/","page":"Solving Factoring problem with Ising machine","title":"Solving Factoring problem with Ising machine","text":"Therefore, solving Factoring problem with Ising machine is a significant task. In this example, we will show how to reduce the Factoring problem to SpinGlass with ProblemReductions.jl and solve it with an Ising machine solver GenericTensorNetworks.jl","category":"page"},{"location":"generated/Ising/#Factoring-SpinGlass-Ising-machine","page":"Solving Factoring problem with Ising machine","title":"Factoring -> SpinGlass -> Ising machine","text":"","category":"section"},{"location":"generated/Ising/","page":"Solving Factoring problem with Ising machine","title":"Solving Factoring problem with Ising machine","text":"Consider a simple Factoring problem: 6 = p times q, we need to figure out the prime factors of 6. In our package, the Factoring problem is modeling under binary representation and when we initialize an instance, we need to offer the information of the number of bits for the two factors. Here, since 6 is a 3 bit number, the number of bits for the two factors are both 2.","category":"page"},{"location":"generated/Ising/","page":"Solving Factoring problem with Ising machine","title":"Solving Factoring problem with Ising machine","text":"Run the following code in Julia REPL:","category":"page"},{"location":"generated/Ising/","page":"Solving Factoring problem with Ising machine","title":"Solving Factoring problem with Ising machine","text":"using ProblemReductions, Graphs\nfactoring = Factoring(2, 2, 6) # initialize the Factoring problem","category":"page"},{"location":"generated/Ising/","page":"Solving Factoring problem with Ising machine","title":"Solving Factoring problem with Ising machine","text":"Using reduction_graph and reduction_paths, we could obtain the way to reduce Factoring to SpinGlass.","category":"page"},{"location":"generated/Ising/","page":"Solving Factoring problem with Ising machine","title":"Solving Factoring problem with Ising machine","text":"g = reduction_graph()\npaths = reduction_paths(g,Factoring,SpinGlass)","category":"page"},{"location":"generated/Ising/","page":"Solving Factoring problem with Ising machine","title":"Solving Factoring problem with Ising machine","text":"The input of reduction_paths is the reduction graph and the types of source and target problems. And the output is a nested vector, each element of the outer vector is a path from source to target problem.","category":"page"},{"location":"generated/Ising/","page":"Solving Factoring problem with Ising machine","title":"Solving Factoring problem with Ising machine","text":"Then we could use reduceto to obtain the corresponding SpinGlass problem.","category":"page"},{"location":"generated/Ising/","page":"Solving Factoring problem with Ising machine","title":"Solving Factoring problem with Ising machine","text":"reduction_result = implement_reduction_path(paths[1], factoring)\ntarget = target_problem(reduction_result)","category":"page"},{"location":"generated/Ising/","page":"Solving Factoring problem with Ising machine","title":"Solving Factoring problem with Ising machine","text":"Note that the output of implement_reduction_path is a AbstractReductionResult, which contains the target problem and reduction information. So we need to extract the target problem by target_problem function.","category":"page"},{"location":"generated/Ising/","page":"Solving Factoring problem with Ising machine","title":"Solving Factoring problem with Ising machine","text":"import GenericTensorNetworks, Graphs # import Ising machine solver\ngtn_problem = GenericTensorNetworks.SpinGlass(\n                  ProblemReductions.nv(target.graph),\n                  vcat(ProblemReductions._vec.(Graphs.edges(target.graph)), [[i] for i=1:Graphs.nv(target.graph)]),\n                  ProblemReductions.weights(target)\n                )\nresult = GenericTensorNetworks.solve(\n                    GenericTensorNetworks.GenericTensorNetwork(gtn_problem),\n                    GenericTensorNetworks.SingleConfigMin()\n                  )[]","category":"page"},{"location":"generated/Ising/","page":"Solving Factoring problem with Ising machine","title":"Solving Factoring problem with Ising machine","text":"Here we use GenericTensorNetworks.jl to solve the SpinGlass problem and obtain the result, we need to extract the solution for source problem from the result.","category":"page"},{"location":"generated/Ising/","page":"Solving Factoring problem with Ising machine","title":"Solving Factoring problem with Ising machine","text":"extract_solution(reduction_result, 1 .- 2 .* Int.(GenericTensorNetworks.read_config(result)))","category":"page"},{"location":"generated/Ising/","page":"Solving Factoring problem with Ising machine","title":"Solving Factoring problem with Ising machine","text":"The result is 01 and 11, decimally 2 and 3, which yields the correct factors of 6.","category":"page"},{"location":"generated/Ising/#Conclusion","page":"Solving Factoring problem with Ising machine","title":"Conclusion","text":"","category":"section"},{"location":"generated/Ising/","page":"Solving Factoring problem with Ising machine","title":"Solving Factoring problem with Ising machine","text":"In this example, we show how to reduce Factoring problem to SpinGlass and solve it with Ising machine solver. This shows the power of ProblemReductions.jl in helping Problem Reduction.","category":"page"},{"location":"generated/Ising/","page":"Solving Factoring problem with Ising machine","title":"Solving Factoring problem with Ising machine","text":"For your convenience, here is how to use ProblemReductions.jl to reduce source problem to target problem:","category":"page"},{"location":"generated/Ising/","page":"Solving Factoring problem with Ising machine","title":"Solving Factoring problem with Ising machine","text":"Initialize the source problem source = SourceProblem(...).\nObtain the reduction paths paths = reduction_paths(reduction_graph(), SourceProblem, TargetProblem).\nImplement the reduction path reduction_result = implement_reduction_path(paths[1], source).\nExtract the target problem target = target_problem(reduction_result).","category":"page"},{"location":"generated/Ising/","page":"Solving Factoring problem with Ising machine","title":"Solving Factoring problem with Ising machine","text":"","category":"page"},{"location":"generated/Ising/","page":"Solving Factoring problem with Ising machine","title":"Solving Factoring problem with Ising machine","text":"This page was generated using Literate.jl.","category":"page"},{"location":"models/#Problems-zoo","page":"Problems zoo","title":"Problems zoo","text":"","category":"section"},{"location":"models/","page":"Problems zoo","title":"Problems zoo","text":"Pages = [\"models.md\"]","category":"page"},{"location":"models/","page":"Problems zoo","title":"Problems zoo","text":"Modules = [ProblemReductions]\nFilter = t -> (typeof(t) === DataType || typeof(t) === UnionAll) && (t <: ProblemReductions.AbstractProblem)","category":"page"},{"location":"models/#ProblemReductions.AbstractProblem","page":"Problems zoo","title":"ProblemReductions.AbstractProblem","text":"AbstractProblem\n\nThe abstract base type of computational problems.\n\nRequired interfaces\n\nvariables, the degrees of freedoms in the computational problem.\nflavors, the flavors (domain) of a degree of freedom.\nenergy, energy the energy (the lower the better) of the input configuration.\nproblem_size, the size of the computational problem. e.g. for a graph, it could be (n_vertices=?, n_edges=?).\n\nOptional interfaces\n\nnum_variables, the number of variables in the computational problem.\nnum_flavors, the number of flavors (domain) of a degree of freedom.\nfindbest, find the best configurations of the input problem.\n\n\n\n\n\n","category":"type"},{"location":"models/#ProblemReductions.CircuitSAT","page":"Problems zoo","title":"ProblemReductions.CircuitSAT","text":"struct CircuitSAT{T, WT<:AbstractArray{T, 1}} <: ConstraintSatisfactionProblem{T}\n\nCircuit satisfiability problem, where the goal is to find an assignment that satisfies the circuit.\n\nFields\n\ncircuit::Circuit: The circuit expression in simplified form.\nsymbols::Vector{Symbol}: The variables in the circuit.\n\nExample\n\nA circuit can be defined with the @circuit macro as follows:\n\njulia> using ProblemReductions\n\njulia> circuit = @circuit begin\n           c = x ∧ y\n           d = x ∨ (c ∧ ¬z)\n       end\nCircuit:\n| c = ∧(x, y)\n| d = ∨(x, ∧(c, ¬(z)))\n\njulia> sat = CircuitSAT(circuit)\nCircuitSAT:\n| c = ∧(x, y)\n| ##var#354 = ¬(z)\n| ##var#353 = ∧(c, ##var#354)\n| d = ∨(x, ##var#353)\nSymbols: [:c, :x, :y, Symbol(\"##var#354\"), :z, Symbol(\"##var#353\"), :d]\n\njulia> sat.symbols\n7-element Vector{Symbol}:\n :c\n :x\n :y\n Symbol(\"##var#354\")\n :z\n Symbol(\"##var#353\")\n :d\n\njulia> flavors(sat)\n2-element Vector{Int64}:\n 0\n 1\n\njulia> energy(sat, [true, false, true, true, false, false, true])\n3\n\njulia> findbest(sat, BruteForce())\n8-element Vector{Vector{Int64}}:\n [0, 0, 0, 1, 0, 0, 0]\n [0, 0, 1, 1, 0, 0, 0]\n [0, 0, 0, 0, 1, 0, 0]\n [0, 0, 1, 0, 1, 0, 0]\n [0, 1, 0, 1, 0, 0, 1]\n [0, 1, 0, 0, 1, 0, 1]\n [1, 1, 1, 0, 1, 0, 1]\n [1, 1, 1, 1, 0, 1, 1]\n\n\n\n\n\n","category":"type"},{"location":"models/#ProblemReductions.Coloring","page":"Problems zoo","title":"ProblemReductions.Coloring","text":"struct Coloring{K, T, WT<:AbstractArray{T, 1}} <: ConstraintSatisfactionProblem{T}\n\nColoring{K}(graph; weights=UnitWeight(nv(graph)))\n\nThe Vertex Coloring (Coloring) problem is defined on a simple graph. Given k kinds of colors, we need to determine whether we can color all vertices on the graph such that no two adjacent vertices share the same color.\n\nFields\n\ngraph is the problem graph.\nweights are associated with the edges of the graph, default to UnitWeight(ne(graph)).\n\nExample\n\nTo initialize a Coloring problem, we need to first define a graph and decide the number of colors.\n\njulia> using ProblemReductions, Graphs\n\njulia> g = smallgraph(:petersen) # define a simple graph, petersen as example\n{10, 15} undirected simple Int64 graph\n\njulia> coloring = Coloring{3}(g)  # 3 colors\nColoring{3, Int64, UnitWeight}(SimpleGraph{Int64}(15, [[2, 5, 6], [1, 3, 7], [2, 4, 8], [3, 5, 9], [1, 4, 10], [1, 8, 9], [2, 9, 10], [3, 6, 10], [4, 6, 7], [5, 7, 8]]), [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])\n\njulia> variables(coloring)\n10-element Vector{Int64}:\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n\njulia> flavors(coloring)\n3-element Vector{Int64}:\n 0\n 1\n 2\n\njulia> is_vertex_coloring(coloring.graph,[1,2,3,1,3,2,1,2,3,1]) #random assignment\nfalse\n\n\n\n\n\n","category":"type"},{"location":"models/#ProblemReductions.ConstraintSatisfactionProblem","page":"Problems zoo","title":"ProblemReductions.ConstraintSatisfactionProblem","text":"ConstraintSatisfactionProblem{T} <: AbstractProblem\n\nThe abstract base type of constraint satisfaction problems. T is the type of the local energy of the constraints.\n\nRequired interfaces\n\nenergy_terms, the specification of the energy terms, it is associated with weights.\nhard_constraints, the specification of the hard constraints. Once the hard constraints are violated, the energy goes to infinity.\nlocal_energy, the local energy for the constraints.\n\n\n\n\n\n","category":"type"},{"location":"models/#ProblemReductions.DominatingSet","page":"Problems zoo","title":"ProblemReductions.DominatingSet","text":"struct DominatingSet{GT<:Graphs.AbstractGraph, T, WT<:AbstractArray{T, 1}} <: ConstraintSatisfactionProblem{T}\n\nDominatingSet(graph::AbstractGraph, weights::AbstractVector=UnitWeight(ne(graph))) -> DominatingSet\n\nDominaing Set is a subset of vertices in a undirected graph such that all the vertices in the set are either in the dominating set or in its first-order neighborhood. The DominatingSet problem is to find the dominating set with minimum number of vertices.\n\nFields\n\ngraph is the problem graph.\nweights::AbstractVector: Weights associated with the vertices of the graph. Defaults to UnitWeight(nv(graph)).\n\nExample\n\nIn the following example, we define a dominating set problem on a path graph with five vertices. To define a DominatingSet problem, we need to specify the graph and possibily the weights associated with vertices. The weights are set as unit by default in the current version and might be generalized to arbitrary positive weights in the following development.\n\njulia> using ProblemReductions, Graphs\n\njulia> graph = path_graph(5)\n{5, 4} undirected simple Int64 graph\n\njulia> DS = DominatingSet(graph)\nDominatingSet{SimpleGraph{Int64}, Int64, UnitWeight}(SimpleGraph{Int64}(4, [[2], [1, 3], [2, 4], [3, 5], [4]]), [1, 1, 1, 1, 1])\n\njulia> variables(DS)  # degrees of freedom\n5-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n\njulia> flavors(DS)  # flavors of the vertices\n2-element Vector{Int64}:\n 0\n 1\n\njulia> energy(DS, [0, 1, 0, 1, 0]) # Positive sample: (size) of a dominating set\n2\n\njulia> energy(DS, [0, 1, 1, 0, 0]) # Negative sample: number of vertices\n3037000502\n\njulia> findbest(DS, BruteForce())  # solve the problem with brute force\n3-element Vector{Vector{Int64}}:\n [1, 0, 0, 1, 0]\n [0, 1, 0, 1, 0]\n [0, 1, 0, 0, 1]\n\n\n\n\n\n","category":"type"},{"location":"models/#ProblemReductions.Factoring","page":"Problems zoo","title":"ProblemReductions.Factoring","text":"struct Factoring <: AbstractProblem\n\nPrime Factorization (Factoring) is to decompose a number m into its prime factors p and q, denoted as m = p  q.\n\nFields\n\nm::Int: number of bits for the first number\nn::Int: number of bits for the second number\ninput::Int: the number to factorize\n\nExample\n\nIn the following example, the two 2 is the factors' bit size and 6 is the number to be factored. 6 is 110 in binary so its factors should be 2-bits number.\n\njulia> using ProblemReductions\n\njulia> factoring = Factoring(2,2,6)\nFactoring(2, 2, 6)\n\njulia> variables(factoring) # return the sum of factors' bit size\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\n\njulia> flavors(factoring)\n2-element Vector{Int64}:\n 0\n 1\n\njulia> energy(factoring,[0,1,1,1]) # 01 -> 2, 11 -> 3\n0\n\n\n\n\n\n","category":"type"},{"location":"models/#ProblemReductions.IndependentSet","page":"Problems zoo","title":"ProblemReductions.IndependentSet","text":"struct IndependentSet{GT<:Graphs.AbstractGraph, T, WT<:AbstractArray{T, 1}} <: ConstraintSatisfactionProblem{T}\n\nIndependentSet(graph::AbstractGraph, weights::AbstractVector=UnitWeight(nv(graph))) -> IndependentSet\n\nIndependent Set is a subset of vertices in a undirected graph such that all the vertices in the set are not connected by edges (or called not adjacent). The maximum IndependentSet problem is to find the independent set with maximum number of vertices, which is a NP-complete problem.\n\nFields\n\ngraph::AbstractGraph: The problem graph.\nweights::AbstractVector: Weights associated with the vertices of the graph. Defaults to UnitWeight(nv(graph)).\n\nExample\n\nIn the following example, we define an independent set problem on a graph with four vertices. To define an IndependentSet problem, we need to specify the graph and possibily the weights associated with vertices. The weights are set as unit by default in the current version and might be generalized to arbitrary positive weights.\n\njulia> using ProblemReductions, Graphs\n\njulia> graph = SimpleGraph(Graphs.SimpleEdge.([(1, 2), (1, 3), (3, 4), (2, 3)]))\n{4, 4} undirected simple Int64 graph\n\njulia> IS = IndependentSet(graph)\nIndependentSet{SimpleGraph{Int64}, Int64, UnitWeight}(SimpleGraph{Int64}(4, [[2, 3], [1, 3], [1, 2, 4], [3]]), [1, 1, 1, 1])\n\njulia> variables(IS)  # degrees of freedom\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\n\njulia> flavors(IS)  # flavors of the vertices\n2-element Vector{Int64}:\n 0\n 1\n\njulia> energy(IS, [1, 0, 0, 1]) # Positive sample: -(size) of an independent set\n-2\n\njulia> energy(IS, [0, 1, 1, 0]) # Negative sample: 0\n3037000500\n\njulia> findbest(IS, BruteForce())  # solve the problem with brute force\n2-element Vector{Vector{Int64}}:\n [1, 0, 0, 1]\n [0, 1, 0, 1]\n\n\n\n\n\n","category":"type"},{"location":"models/#ProblemReductions.KSatisfiability","page":"Problems zoo","title":"ProblemReductions.KSatisfiability","text":"struct KSatisfiability{K, S, T, WT<:(AbstractArray{T})} <: ProblemReductions.AbstractSatisfiabilityProblem{S, T}\n\nThe satisfiability problem for k-SAT, where the goal is to find an assignment that satisfies the CNF.\n\nFields\n\nvariables::Vector{T}: The variables in the CNF.\ncnf::CNF{T}: The CNF expression.\n\n\n\n\n\n","category":"type"},{"location":"models/#ProblemReductions.Matching","page":"Problems zoo","title":"ProblemReductions.Matching","text":"struct Matching{T, WT<:AbstractArray{T, 1}} <: ConstraintSatisfactionProblem{T}\n\nThe Vertex matching problem.\n\nPositional arguments\n\ngraph is the problem graph.\nweights are associated with the edges of the graph.\n\n\n\n\n\n","category":"type"},{"location":"models/#ProblemReductions.MaxCut","page":"Problems zoo","title":"ProblemReductions.MaxCut","text":"struct MaxCut{T, WT<:AbstractArray{T, 1}} <: ConstraintSatisfactionProblem{T}\n\nMax Cut problem is defined on weighted graphs. The goal is to find a partition of the vertices into two sets such that the sum of the weights of the edges between the two sets is maximized.\n\nPositional arguments\n\ngraph is the problem graph.\nweights are associated with the edges of the graph. We have ensure that the weights are in the same order as the edges in edges(graph).\n\nExample\n\nIn the following example, we solve a Max Cut problem on a complete graph with 3 vertices and edge weights [1,2,3].\n\njulia> using ProblemReductions, Graphs\n\njulia> g = complete_graph(3)\n{3, 3} undirected simple Int64 graph\n\njulia> maxcut = MaxCut(g,[1,2,3]) # specify the weights of the edges\nMaxCut{Int64, Vector{Int64}}(SimpleGraph{Int64}(3, [[2, 3], [1, 3], [1, 2]]), [1, 2, 3])\n\njulia> mc = set_weights(maxcut, [2,1,3]) # set the weights and get a new instance\nMaxCut{Int64, Vector{Int64}}(SimpleGraph{Int64}(3, [[2, 3], [1, 3], [1, 2]]), [2, 1, 3])\n\n\njulia> num_variables(maxcut) # return the number of vertices\n3\n\njulia> flavors(maxcut) # return the flavors of the vertices\n2-element Vector{Int64}:\n 0\n 1\n\njulia> energy(maxcut, [0,1,0]) # return the energy of the configuration\n-4\n\njulia> findbest(maxcut, BruteForce()) # find the best configuration\n2-element Vector{Vector{Int64}}:\n [1, 1, 0]\n [0, 0, 1]\n\n\n\n\n\n","category":"type"},{"location":"models/#ProblemReductions.MaximalIS","page":"Problems zoo","title":"ProblemReductions.MaximalIS","text":"struct MaximalIS{T, WT<:AbstractArray{T, 1}} <: ConstraintSatisfactionProblem{T}\n\nMaximal independent set is a problem that very similar to the IndependentSet problem. The difference is that the solution space of a maximal indepdent set problem does not include the independent sets that can be extended by adding one more vertex.\n\nFields\n\ngraph is the problem graph.\nweights are associated with the vertices of the graph.\n\nExample\n\nIn the following example, we define a maximal independent set problem on a graph with four vertices. To define a MaximalIS problem, we need to specify the graph and possibily the weights associated with vertices. The weights are set as unit by default in the current version and might be generalized to arbitrary positive weights in the following development.\n\njulia> using ProblemReductions, Graphs\n\njulia> graph = SimpleGraph(Graphs.SimpleEdge.([(1, 2), (1, 3), (3, 4), (2, 3), (1, 4)]))\n{4, 5} undirected simple Int64 graph\n\njulia> problem = MaximalIS(graph)\nMaximalIS{Int64, UnitWeight}(SimpleGraph{Int64}(5, [[2, 3, 4], [1, 3], [1, 2, 4], [1, 3]]), [1, 1, 1, 1])\n\njulia> variables(problem)  # degrees of freedom\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\n\njulia> flavors(problem)\n2-element Vector{Int64}:\n 0\n 1\n\njulia> energy(problem, [0, 1, 0, 0])  # unlike the independent set, this configuration is not a valid solution\n3037000500\n\njulia> findbest(problem, BruteForce())\n1-element Vector{Vector{Int64}}:\n [0, 1, 0, 1]\n\n\n\n\n\n","category":"type"},{"location":"models/#ProblemReductions.PaintShop","page":"Problems zoo","title":"ProblemReductions.PaintShop","text":"struct PaintShop{LT} <: ConstraintSatisfactionProblem{Int64}\n\nThe binary paint shop problem is defined as follows: we are given a 2m length sequence containing m cars, where each car appears twice. Each car need to be colored red in one occurrence, and blue in the other. We need to choose which occurrence for each car to color with which color — the goal is to minimize the number of times we need to change the current color.\n\nFields\n\nsequence is a vector of symbols, each symbol is associated with a color.\nisfirst is a vector of boolean numbers, indicating whether the symbol is the first appearance in the sequence.\n\nExample\n\nIn the following example, we define a paint shop problem with 6 cars.\n\njulia> using ProblemReductions\n\njulia> problem = PaintShop([\"a\",\"b\",\"a\",\"c\",\"c\",\"b\"])\nPaintShop{String}([\"a\", \"b\", \"a\", \"c\", \"c\", \"b\"], Bool[1, 1, 0, 1, 0, 0])\n\njulia> variables(problem)\n3-element Vector{String}:\n \"a\"\n \"b\"\n \"c\"\n\njulia> flavors(problem)\n2-element Vector{Int64}:\n 0\n 1\n\njulia> energy(problem, [0, 1, 0])\n4\n\njulia> findbest(problem, BruteForce())\n2-element Vector{Vector{Int64}}:\n [1, 0, 0]\n [0, 1, 1]\n\n\n\n\n\n","category":"type"},{"location":"models/#ProblemReductions.QUBO","page":"Problems zoo","title":"ProblemReductions.QUBO","text":"struct QUBO{T<:Real} <: ConstraintSatisfactionProblem{T<:Real}\n\nThe quadratic unconstrained binary optimization.\n\nE = sum_ij Q_ij x_i x_j\n\nwhere x_i in 0 1.\n\nArguments\n\nmatrix::AbstractMatrix: the matrix Q of the QUBO problem.\n\njulia> using ProblemReductions, Graphs\n       # Matrix method\n\njulia> Q = [1. 0 0; 0 1 0; 0 0 1]\n3×3 Matrix{Float64}:\n 1.0  0.0  0.0\n 0.0  1.0  0.0\n 0.0  0.0  1.0\n\njulia> QUBO01 = QUBO(Q)\n       # Graph method\nQUBO{Float64}([1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0])\n\njulia> graph = SimpleGraph(3)\n{3, 0} undirected simple Int64 graph\n\njulia> QUBO02 = QUBO(graph, Float64[], [1., 1., 1.])\nQUBO{Float64}([1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0])\n\njulia> variables(QUBO01)  # degrees of freedom\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> variables(QUBO02)\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> flavors(QUBO01)  # flavors of the vertices\n2-element Vector{Int64}:\n 0\n 1\n\njulia> energy(QUBO01, [0, 1, 0])\n1.0\n\njulia> energy(QUBO02, [0, 1, 0])\n1.0\n\njulia> findbest(QUBO01, BruteForce())  # solve the problem with brute force\n1-element Vector{Vector{Int64}}:\n [0, 0, 0]\n\njulia> findbest(QUBO02, BruteForce())\n1-element Vector{Vector{Int64}}:\n [0, 0, 0]\n\n\n\n\n\n","category":"type"},{"location":"models/#ProblemReductions.Satisfiability","page":"Problems zoo","title":"ProblemReductions.Satisfiability","text":"struct Satisfiability{S, T, WT<:(AbstractArray{T})} <: ProblemReductions.AbstractSatisfiabilityProblem{S, T}\n\nSatisfiability (also called SAT) problem is to find the boolean assignment that satisfies a Conjunctive Normal Form (CNF). A tipical CNF would look like:\n\nleft(l_11 vee ldots vee l_1 n_1right) wedge ldots wedgeleft(l_m 1 vee ldots vee l_m n_mright)\n\nwhere literals are joint by vee to for m clauses and clauses are joint by wedge to form a CNF.\n\nWe should note that all the SAT problem problem can be reduced to the 3-SAT problem and it can be proved that 3-SAT is NP-complete.\n\nFields\n\ncnf is a conjunctive normal form (CNF) for specifying the satisfiability problems.\nweights are associated with clauses.\n\nExample\n\nIn the following example, we define a satisfiability problem with two clauses.\n\njulia> using ProblemReductions\n\njulia> bv1, bv2, bv3 = BoolVar.([\"x\", \"y\", \"z\"])\n3-element Vector{BoolVar{String}}:\n x\n y\n z\n\njulia> clause1 = CNFClause([bv1, bv2, bv3])\nx ∨ y ∨ z\n\njulia> clause2 = CNFClause([BoolVar(\"w\"), bv1, BoolVar(\"x\", true)])\nw ∨ x ∨ ¬x\n\njulia> cnf_test = CNF([clause1, clause2])\n(x ∨ y ∨ z) ∧ (w ∨ x ∨ ¬x)\n\njulia> sat_test = Satisfiability(cnf_test)\nSatisfiability{String, Int64, UnitWeight}([\"x\", \"y\", \"z\", \"w\"], [1, 1], (x ∨ y ∨ z) ∧ (w ∨ x ∨ ¬x))\n\n\n\n\n\n","category":"type"},{"location":"models/#ProblemReductions.SetCovering","page":"Problems zoo","title":"ProblemReductions.SetCovering","text":"struct SetCovering{ET, T, WT<:AbstractArray{T, 1}} <: ConstraintSatisfactionProblem{T}\n\nThe Set Covering problem is defined as follow: given a universe of elements and a collection of subsets of the universe, each set is associated with a weight.  The goal is to find a subset of sets that covers all the elements with the minimum total weight.\n\nPositional arguments\n\nelements is a vector of elements in the universe.\nsets is a vector of vectors, a collection of subsets of universe , each set is associated with a weight specified in weights.\nweights are associated with sets.\n\njulia> using ProblemReductions\n\njulia> subsets = [[1, 2, 3], [2, 4], [1, 4]]\n3-element Vector{Vector{Int64}}:\n [1, 2, 3]\n [2, 4]\n [1, 4]\n\njulia> weights = [1, 2, 3]\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> setcovering = SetCovering(subsets, weights)\nSetCovering{Int64, Int64, Vector{Int64}}([1, 2, 3, 4], [[1, 2, 3], [2, 4], [1, 4]], [1, 2, 3])\n\njulia> variables(setcovering)  # degrees of freedom\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> energy(setcovering, [1, 0, 1])  # cost of a configuration\n4\n\njulia> energy(setcovering, [0, 1, 1])\n3037000500\n\njulia> sc = set_weights(setcovering, [1, 2, 3])  # set the weights of the subsets\nSetCovering{Int64, Int64, Vector{Int64}}([1, 2, 3, 4], [[1, 2, 3], [2, 4], [1, 4]], [1, 2, 3])\n\n\n\n\n\n","category":"type"},{"location":"models/#ProblemReductions.SetPacking","page":"Problems zoo","title":"ProblemReductions.SetPacking","text":"struct SetPacking{ET, T, WT<:AbstractArray{T, 1}} <: ConstraintSatisfactionProblem{T}\n\nSetPacking(elements::AbstractVector, sets::AbstractVector, weights::AbstractVector=UnitWeight(length(sets))) -> SetPacking\n\nA packing is a set of sets where each set is pairwise disjoint from each other. The maximum (weighted) packing problem is to find the maximum packing for a given union and a set of subsets.\n\nFields\n\nelements is a vector of elements in the universe.\nsets is a vector of vectors, each set is associated with a weight specified in weights.\nweights are associated with sets. Defaults to UnitWeight(length(sets)).\n\nExample\n\nIn the following example, we define a set packing problem with five subsets. To define a SetPacking problem, we need to specify the set of subsets and possibily the weights associated with these subsets. The weights are set as unit by default in the current version and might be generalized to arbitrary positive weights in the following development. Besides, the elements would be automatically counted by the construction function.\n\njulia> using ProblemReductions\n\njulia> sets = [[1, 2, 5], [1, 3], [2, 4], [3, 6], [2, 3, 6]]\n5-element Vector{Vector{Int64}}:\n [1, 2, 5]\n [1, 3]\n [2, 4]\n [3, 6]\n [2, 3, 6]\n\njulia> SP = SetPacking(sets)\nSetPacking{Int64, Int64, UnitWeight}([1, 2, 5, 3, 4, 6], [[1, 2, 5], [1, 3], [2, 4], [3, 6], [2, 3, 6]], [1, 1, 1, 1, 1])\n\njulia> variables(SP)  # degrees of freedom\n5-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n\njulia> flavors(SP)  # flavors of the subsets\n2-element Vector{Int64}:\n 0\n 1\n\njulia> energy(SP, [1, 0, 0, 1, 0]) # Positive sample: -(size) of a packing\n-2\n\njulia> energy(SP, [1, 0, 1, 1, 0]) # Negative sample: 0\n3037000500\n\njulia> findbest(SP, BruteForce())  # solve the problem with brute force\n3-element Vector{Vector{Int64}}:\n [0, 1, 1, 0, 0]\n [1, 0, 0, 1, 0]\n [0, 0, 1, 1, 0]\n\n\n\n\n\n","category":"type"},{"location":"models/#ProblemReductions.SpinGlass","page":"Problems zoo","title":"ProblemReductions.SpinGlass","text":"struct SpinGlass{GT<:Graphs.AbstractGraph, T, WT<:AbstractArray{T, 1}} <: ConstraintSatisfactionProblem{T}\n\nSpinGlass(graph::AbstractGraph, weights::AbstractVector)\nSpinGlass(graph::SimpleGraph, J, h=zeros(nv(graph)))\n\nSpin Glass is a type of disordered magnetic system that exhibits a glassy behavior. The Hamiltonian of the system on a simple graph G is given by\n\nH(G sigma) = sum_(ij) in E(G) J_ij sigma_i sigma_j + sum_i in V(G) h_i sigma_i\n\nwhere J_ij in mathbbR is the coupling strength between spins i and j, h_i in mathbbR is the external field on spin i, and sigma_i is the spin variable that can take values in -1 1 for spin up and spin down, respectively.\n\nThis definition naturally extends to the case of a HyperGraph:\n\nH(G sigma) = sum_e in E(G) J_e prod_ksigma_k + sum_i in V(G) h_i sigma_i\n\nwhere J_e is the coupling strength associated with hyperedge e, and the product is over all spins in the hyperedge.\n\nFields\n\ngraph is a graph object.\nJ are the coupling strengths associated with the edges.\nh are the external fields associated with the vertices.\n\nExample\n\nIn the following example, we define a spin glass problem on a 4-vertex graph with given coupling strengths on edges and external fields on vertices.\n\njulia> using ProblemReductions, ProblemReductions.Graphs\n\njulia> graph = SimpleGraph(Graphs.SimpleEdge.([(1, 2), (1, 3), (3, 4), (2, 3)]))\n{4, 4} undirected simple Int64 graph\n\njulia> J = [1, -1, 1, -1]  # coupling strength\n4-element Vector{Int64}:\n  1\n -1\n  1\n -1\n\njulia> h = [1, -1, -1, 1]  # external field\n4-element Vector{Int64}:\n  1\n -1\n -1\n  1\n\njulia> spinglass = SpinGlass(graph, J, h)  # Define a spin glass problem\nSpinGlass{SimpleGraph{Int64}, Int64, Vector{Int64}}(SimpleGraph{Int64}(4, [[2, 3], [1, 3], [1, 2, 4], [3]]), [1, -1, 1, -1], [1, -1, -1, 1])\n\njulia> variables(spinglass)  # degrees of freedom\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\n\njulia> flavors(spinglass)  # flavors of the spins\n2-element Vector{Int64}:\n  1\n -1\n\njulia> energy(spinglass, [-1, 1, 1, -1])  # energy of a configuration\n-2\n\njulia> findbest(spinglass, BruteForce())  # solve the problem with brute force\n1-element Vector{Vector{Int64}}:\n [-1, 1, -1, -1]\n\n\n\n\n\n","category":"type"},{"location":"models/#ProblemReductions.VertexCovering","page":"Problems zoo","title":"ProblemReductions.VertexCovering","text":"struct VertexCovering{T, WT<:AbstractArray{T, 1}} <: ConstraintSatisfactionProblem{T}\n\nA Vertex Cover is a subset of vertices in a graph, such that for an arbitrary edge, the subset includes at least one of the endpoints. The minimum vertex covering problem is to find the minimum vertex cover for a given graph, which is a NP-complete problem.\n\nFields\n\ngraph is a graph object.\nweights are associated with the vertices of the graph, default to UnitWeight(nv(graph)).\n\nExample\n\nIn the following example, we define a vertex covering problem on a graph with four vertices. To define a VertexCovering problem, we need to specify the graph and the weights associated with edges. The weights are by default set as unit.\n\njulia> using ProblemReductions, Graphs\n\njulia> graph = SimpleGraph(Graphs.SimpleEdge.([(1,2), (1,3), (3,4), (2,3), (1,4)]))\n{4, 5} undirected simple Int64 graph\n\njulia> weights = [1, 3, 1, 4]\n4-element Vector{Int64}:\n 1\n 3\n 1\n 4\n\njulia> VC= VertexCovering(graph, weights)\nVertexCovering{Int64, Vector{Int64}}(SimpleGraph{Int64}(5, [[2, 3, 4], [1, 3], [1, 2, 4], [1, 3]]), [1, 3, 1, 4])\n\njulia> variables(VC)  # degrees of freedom\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\n\njulia> energy(VC, [1, 0, 0, 1]) # Negative sample\n3037000500\n\njulia> energy(VC, [0, 1, 1, 0]) # Positive sample\n3037000500\n\njulia> findbest(VC, BruteForce())  # solve the problem with brute force\n1-element Vector{Vector{Int64}}:\n [1, 0, 1, 0]\n\njulia> VC02 = set_weights(VC, [1, 2, 3, 4])  # set the weights of the subsets\nVertexCovering{Int64, Vector{Int64}}(SimpleGraph{Int64}(5, [[2, 3, 4], [1, 3], [1, 2, 4], [1, 3]]), [1, 2, 3, 4])\n\n\n\n\n\n","category":"type"},{"location":"rules/spinglass_sat/#CircuitSAT-SpinGlass","page":"CircuitSAT -> SpinGlass","title":"CircuitSAT -> SpinGlass","text":"","category":"section"},{"location":"rules/spinglass_sat/","page":"CircuitSAT -> SpinGlass","title":"CircuitSAT -> SpinGlass","text":"In this tutorial, we will demonstrate how to use the Spinglass model to solve the circuit satisfiability problem.","category":"page"},{"location":"rules/spinglass_sat/","page":"CircuitSAT -> SpinGlass","title":"CircuitSAT -> SpinGlass","text":"We first define a simple Circuit using the @circuit macro. And then we convert the circuit to a CircuitSAT problem.","category":"page"},{"location":"rules/spinglass_sat/","page":"CircuitSAT -> SpinGlass","title":"CircuitSAT -> SpinGlass","text":"using ProblemReductions\n\ncircuit = @circuit begin\n    c = x ∧ y\n    d = x ∨ (¬c ∧ ¬z)\nend\ncircuitsat = CircuitSAT(circuit)\nvariables(circuitsat)\ncircuitsat.symbols","category":"page"},{"location":"rules/spinglass_sat/","page":"CircuitSAT -> SpinGlass","title":"CircuitSAT -> SpinGlass","text":"The resulting circuitsat expands the expression to a list of simple clauses. The variables are mapped to integers that pointing to the symbols that stored in the symbols field.","category":"page"},{"location":"rules/spinglass_sat/","page":"CircuitSAT -> SpinGlass","title":"CircuitSAT -> SpinGlass","text":"The we can convert the circuit to a SpinGlass problem using the reduceto function.","category":"page"},{"location":"rules/spinglass_sat/","page":"CircuitSAT -> SpinGlass","title":"CircuitSAT -> SpinGlass","text":"result = reduceto(SpinGlass{<:SimpleGraph}, circuitsat)","category":"page"},{"location":"rules/spinglass_sat/","page":"CircuitSAT -> SpinGlass","title":"CircuitSAT -> SpinGlass","text":"The resulting result is a ReductionCircuitToSpinGlass instance that contains the spin glass problem.","category":"page"},{"location":"rules/spinglass_sat/","page":"CircuitSAT -> SpinGlass","title":"CircuitSAT -> SpinGlass","text":"With the result instance, we can define a logic gadget that maps the spin glass variables to the circuit variables.","category":"page"},{"location":"rules/spinglass_sat/","page":"CircuitSAT -> SpinGlass","title":"CircuitSAT -> SpinGlass","text":"indexof(x) = findfirst(==(x), circuitsat.symbols[sortperm(result.variables)])\ngadget = LogicGadget(result.spinglass, indexof.([:x, :y, :z]), [indexof(:d)])\ntb = truth_table(gadget; variables=circuitsat.symbols[result.variables])","category":"page"},{"location":"rules/spinglass_sat/","page":"CircuitSAT -> SpinGlass","title":"CircuitSAT -> SpinGlass","text":"The gadget is a LogicGadget instance that maps the spin glass variables to the circuit variables. The truth_table function generates the truth table of the gadget.","category":"page"},{"location":"ref/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"ref/","page":"Reference","title":"Reference","text":"Pages = [\"ref.md\"]","category":"page"},{"location":"ref/","page":"Reference","title":"Reference","text":"Modules = [ProblemReductions]\nFilter = t -> !((typeof(t) === DataType || typeof(t) === UnionAll) && (t <: ProblemReductions.AbstractProblem))","category":"page"},{"location":"ref/#ProblemReductions.AbstractReductionResult","page":"Reference","title":"ProblemReductions.AbstractReductionResult","text":"abstract type AbstractReductionResult\n\nThe base type for a reduction result.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.BoolVar","page":"Reference","title":"ProblemReductions.BoolVar","text":"BoolVar{T}\nBoolVar(name, neg)\n\nBoolean variable for constructing CNF clauses.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.BruteForce","page":"Reference","title":"ProblemReductions.BruteForce","text":"struct BruteForce\n\nA brute force method to find the best configuration of a problem.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.CNF","page":"Reference","title":"ProblemReductions.CNF","text":"CNF{T}\nCNF(clauses)\n\nBoolean expression in conjunctive normal form. clauses is a vector of CNFClause, if and only if all clauses are satisfied, this CNF is satisfied.\n\nExample\n\nUnder development\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.CNFClause","page":"Reference","title":"ProblemReductions.CNFClause","text":"CNFClause{T}\nCNFClause(vars)\n\nA clause in CNF, its value is the logical or of vars, where vars is a vector of BoolVar.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.Circuit","page":"Reference","title":"ProblemReductions.Circuit","text":"struct Circuit\n\nA circuit expression is a sequence of assignments.\n\nFields\n\nexprs::Vector{Assignment}: The assignments in the circuit.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.ConcatenatedReduction","page":"Reference","title":"ProblemReductions.ConcatenatedReduction","text":"struct ConcatenatedReduction\n\nA sequence of reductions.\n\nFields\n\nsequence::Vector{Any}: The sequence of reductions.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.GridGraph","page":"Reference","title":"ProblemReductions.GridGraph","text":"GridGraph is a unit disk graph with integer coordinates.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.HyperGraph","page":"Reference","title":"ProblemReductions.HyperGraph","text":"struct HyperGraph <: Graphs.AbstractGraph{Int64}\n\nA hypergraph is a generalization of a graph in which an edge can connect any number of vertices.\n\nFields\n\nn::Int: the number of vertices\nedges::Vector{Vector{Int}}: a vector of vectors of integers, where each vector represents a hyperedge connecting the vertices with the corresponding indices.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.LocalConstraint","page":"Reference","title":"ProblemReductions.LocalConstraint","text":"struct LocalConstraint{ST}\n\nThe local constraint of the problem.\n\nFields\n\nvariables: the indices of the variables involved in the constraint.\nspecification: the specification of the constraint.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.LogicGadget","page":"Reference","title":"ProblemReductions.LogicGadget","text":"struct LogicGadget{PT<:AbstractProblem}\n\nThe logic gadget defined on an computational model.\n\nFields\n\nproblem::PT: the computational model, e.g., SpinGlass.\ninputs::Vector{Int}: the input variables.\noutputs::Vector{Int}: the output variables.\n\nReferences\n\nWhat are the cost function for NAND and NOR gates?\nNguyen, M.-T., Liu, J.-G., Wurtz, J., Lukin, M.D., Wang, S.-T., Pichler, H., 2023. Quantum Optimization with Arbitrary Connectivity Using Rydberg Atom Arrays. PRX Quantum 4, 010316.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.ReductionCircuitToSpinGlass","page":"Reference","title":"ProblemReductions.ReductionCircuitToSpinGlass","text":"struct ReductionCircuitToSpinGlass{GT, T} <: AbstractReductionResult\n\nThe reduction result of a circuit to a spin glass problem.\n\nFields\n\nnum_source_vars::Int: the number of variables in the source circuit.\nspinglass::SpinGlass{GT, T}: the spin glass problem.\nvariables::Vector{Int}: the variables in the spin glass problem.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.ReductionFactoringToSat","page":"Reference","title":"ProblemReductions.ReductionFactoringToSat","text":"struct ReductionFactoringToSat <: AbstractReductionResult\n\nThe reduction result of a  factoring problem to a CircuitSAT problem.\n\nFields\n\ncircuit::CircuitSAT: the CircuitSAT problem.\np::Vector{Int}: the first number to multiply (store bit locations)\nq::Vector{Int}: the second number to multiply.\nm::Vector{Int}: the result of the multiplication.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.ReductionGraph","page":"Reference","title":"ProblemReductions.ReductionGraph","text":"struct ReductionGraph\n\nA directed graph representing the reduction paths between different problems. A node represents a problem type, and an edge represents a reduction rule from one problem type to another.\n\nFields\n\ngraph::Graphs.SimpleGraphs.SimpleDiGraph{Int64}\nnodes::Vector{Any}\nmethod_table::Dict{Pair{Int64, Int64}, Function}\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.ReductionIndependentSetToSetPacking","page":"Reference","title":"ProblemReductions.ReductionIndependentSetToSetPacking","text":"struct ReductionIndependentSetToSetPacking{ET} <: AbstractReductionResult\n\nThe reduction result of an Independent Set problem to a Set Packing problem.\n\nFields\n\ntarget::SetPacking\nvertices_list::Vector{Int64}\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.ReductionMaxCutToSpinGlass","page":"Reference","title":"ProblemReductions.ReductionMaxCutToSpinGlass","text":"struct ReductionMaxCutToSpinGlass{GT, T} <: AbstractReductionResult\n\nThe reduction result of a maxcut to a spin glass problem.\n\nFields\n\nspinglass::SpinGlass{GT, T}: the spin glass problem.\n\nWe only consider a simple reduction from MaxCut to SpinGlass(the graph must be SimpleGraph).\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.ReductionPath","page":"Reference","title":"ProblemReductions.ReductionPath","text":"struct ReductionPath\n\nA sequence of reductions.\n\nFields\n\nnodes::Vector{AbstractProblem}: The sequence of problem types.\nmethods::Vector{Function}: The sequence of methods used to reduce the problems.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.ReductionQUBOToSpinGlass","page":"Reference","title":"ProblemReductions.ReductionQUBOToSpinGlass","text":"struct ReductionQUBOToSpinGlass{GT, T} <: AbstractReductionResult\n\nThe reduction result of a qubo to a spin glass problem.\n\nFields\n\nspinglass::SpinGlass{GT, T}: the spin glass problem.\n\nWe only consider a simple reduction from QUBO to SpinGlass(the graph must be SimpleGraph).\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.ReductionSATTo3SAT","page":"Reference","title":"ProblemReductions.ReductionSATTo3SAT","text":"The reduction result of a general SAT problem to a 3-SAT problem.\n\nFields\n\nsat_source::Satisfiability{GT, T}: the source general SAT problem.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.ReductionSATToCircuit","page":"Reference","title":"ProblemReductions.ReductionSATToCircuit","text":"struct ReductionSATToCircuit <: AbstractReductionResult\n\nThe reduction result of an SAT problem o a Circuit SAT problem.\n\nFields\n\ntarget::CircuitSAT: the target problem.\ntarget::CircuitSAT\nsat_symbols::Vector{Symbol}\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.ReductionSATToDominatingSet","page":"Reference","title":"ProblemReductions.ReductionSATToDominatingSet","text":"struct ReductionSATToDominatingSet{GT<:Graphs.AbstractGraph} <: AbstractReductionResult\n\nThe reduction result of a general SAT problem to an Dominating Set problem.\n\nFields\n\ntarget::DominatingSet\nnum_literals::Int64\nnum_clauses::Int64\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.ReductionSATToIndependentSet","page":"Reference","title":"ProblemReductions.ReductionSATToIndependentSet","text":"struct ReductionSATToIndependentSet{S, GT<:Graphs.AbstractGraph, T, WT<:AbstractArray{T, 1}} <: AbstractReductionResult\n\nThe reduction result of a general SAT problem to an Independent Set problem.\n\nFields\n\ntarget::IndependentSet\nliterals::Array{BoolVar{S}, 1} where S\nsource_variables::Vector\nnum_clauses::Int64\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.ReductionSatToColoring","page":"Reference","title":"ProblemReductions.ReductionSatToColoring","text":"struct ReductionSatToColoring{K, S, T, WT<:AbstractArray{T, 1}} <: AbstractReductionResult\n\nThe reduction result of a Sat problem to a Coloring problem.\n\nFields\n\nColoring{K, T, WT<:AbstractVector{T}}: the coloring problem, where K is the number of colors and WT is the weights type. \nvarlabel, used to filter extra variables\n\nNote: The coloring problem is a 3 coloring problem, in which a auxiliary color is used Auxiliary color => 2.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.ReductionSpinGlassToMaxCut","page":"Reference","title":"ProblemReductions.ReductionSpinGlassToMaxCut","text":"struct ReductionSpinGlassToMaxCut{WT} <: AbstractReductionResult\n\nThe reduction result of a spin glass to a maxcut problem.\n\nFields\n\nmaxcut::MaxCut{WT}: the MaxCut problem.\nancilla::Int: the ancilla vertex.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.ReductionSpinGlassToQUBO","page":"Reference","title":"ProblemReductions.ReductionSpinGlassToQUBO","text":"struct ReductionSpinGlassToQUBO{WT} <: AbstractReductionResult\n\nThe reduction result of a spin glass to a QUBO problem.\n\nFields\n\nqubo::QUBO{WT}: the QUBO problem.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.ReductionVertexCoveringToSetCovering","page":"Reference","title":"ProblemReductions.ReductionVertexCoveringToSetCovering","text":"struct ReductionVertexCoveringToSetCovering{ET, T, WT<:AbstractArray{T, 1}} <: AbstractReductionResult\n\nThe reduction result of a vertex covering to a set covering problem.\n\nFields\n\nsetcovering::SetCovering{Int,T,WT}: the set covering problem, where ET is the sets type and WT is the weights type.\nedgelabel: map each edge to a number in order to identify the edge (otherwise the vector would be cluttering)\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.StaticBitVector","page":"Reference","title":"ProblemReductions.StaticBitVector","text":"StaticBitVector{N,C} = StaticElementVector{N,1,C}\nStaticBitVector(x::AbstractVector)\n\nExamples\n\njulia> sb = StaticBitVector([1,0,0,1,1])\n10011\n\njulia> sb[3]\n0x0000000000000000\n\njulia> collect(Int, sb)\n5-element Vector{Int64}:\n 1\n 0\n 0\n 1\n 1\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.StaticElementVector","page":"Reference","title":"ProblemReductions.StaticElementVector","text":"StaticElementVector{N,S,C}\nStaticElementVector(nflavor::Int, x::AbstractVector)\n\nN is the length of vector, C is the size of storage in unit of UInt64, S is the stride defined as the log2(# of flavors). When the number of flavors is 2, it is a StaticBitVector.\n\nFields\n\ndata is a tuple of UInt64 for storing the configuration of static elements.\n\nExamples\n\njulia> ev = StaticElementVector(3, [1,2,0,1,2])\n12012\n\njulia> ev[2]\n0x0000000000000002\n\njulia> collect(Int, ev)\n5-element Vector{Int64}:\n 1\n 2\n 0\n 1\n 2\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.TruthTable","page":"Reference","title":"ProblemReductions.TruthTable","text":"struct TruthTable{N, T}\n\nThe truth table.\n\nFields\n\ninputs::Vector{T}: The input values.\noutputs::Vector{T}: The output values.\nvalues::Vector{BitStr{N, Int}}: The truth table values.\n\nExamples\n\njulia> tt = TruthTable(['a', 'b'], ['c'], [bit\"0\", bit\"0\", bit\"0\", bit\"1\"])\n┌───┬───┬───┐\n│ a │ b │ c │\n├───┼───┼───┤\n│ 0 │ 0 │ 0 │\n│ 1 │ 0 │ 0 │\n│ 0 │ 1 │ 0 │\n│ 1 │ 1 │ 1 │\n└───┴───┴───┘\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.UnitDiskGraph","page":"Reference","title":"ProblemReductions.UnitDiskGraph","text":"struct UnitDiskGraph{D, T} <: Graphs.AbstractGraph{Int64}\n\nA unit disk graph is a graph in which the vertices are points in a plane and two vertices are connected by an edge if and only if the Euclidean distance between them is at most a given radius.\n\nFields\n\nlocations::Vector{NTuple{D, T}}: the locations of the vertices\nradius::Float64: the radius of the unit disk\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.UnitWeight","page":"Reference","title":"ProblemReductions.UnitWeight","text":"UnitWeight <: AbstractVector{Int}\n\nThe unit weight vector of length n.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.:¬-Union{Tuple{BoolVar{T}}, Tuple{T}} where T","page":"Reference","title":"ProblemReductions.:¬","text":"¬(var::BoolVar)\n\nNegation of a boolean variables of type BoolVar.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.:∧-Union{Tuple{T}, Tuple{CNFClause{T}, Vararg{CNFClause{T}}}} where T","page":"Reference","title":"ProblemReductions.:∧","text":"∧(vars...)\n\nLogical and applied on CNFClause and CNF. Returns a new CNF.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.:∨-Union{Tuple{T}, Tuple{BoolVar{T}, Vararg{BoolVar{T}}}} where T","page":"Reference","title":"ProblemReductions.:∨","text":"∨(vars...)\n\nLogical or applied on BoolVar and CNFClause. Returns a CNFClause.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.configuration_space_size-Tuple{AbstractProblem}","page":"Reference","title":"ProblemReductions.configuration_space_size","text":"configuration_space_size(problem::AbstractProblem) -> Any\n\n\nReturn the log2 size of the configuration space of the problem.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.energy","page":"Reference","title":"ProblemReductions.energy","text":"energy(problem::AbstractProblem, config) -> Real\n\nEnergy of the problem given the configuration config. The lower the energy, the better the configuration.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.energy_terms","page":"Reference","title":"ProblemReductions.energy_terms","text":"energy_terms(problem::AbstractProblem) -> Vector{LocalConstraint}\n\nThe energy terms of the problem. Each term is associated with weights.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.extract_multiple_solutions-Tuple{AbstractReductionResult, Any}","page":"Reference","title":"ProblemReductions.extract_multiple_solutions","text":"extract_multiple_solutions(reduction::AbstractReductionResult, solution_set)\n\nExtract multiple solutions together solution_set of the target problem to the original problem.\n\nArguments\n\nreduction: The reduction result.\nsolution_set: The set of multiple solutions of the target problem.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.extract_solution","page":"Reference","title":"ProblemReductions.extract_solution","text":"extract_solution(reduction::AbstractReductionResult, solution)\n\nExtract the solution solution of the target problem to the original problem.\n\nArguments\n\nreduction: The reduction result.\nsolution: The solution of the target problem.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.findbest","page":"Reference","title":"ProblemReductions.findbest","text":"findbest(problem::AbstractProblem, method) -> Vector\n\nFind the best configurations of the problem using the method.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.flavor_to_logical-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Reference","title":"ProblemReductions.flavor_to_logical","text":"flavor_to_logical(::Type{T}, flavor) -> T\n\nConvert the flavor to a logical value.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.flavors-Tuple{GT} where GT<:AbstractProblem","page":"Reference","title":"ProblemReductions.flavors","text":"flavors(::Type{<:AbstractProblem}) -> Vector\n\nReturns a vector of integers as the flavors (domain) of a degree of freedom.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.hard_constraints","page":"Reference","title":"ProblemReductions.hard_constraints","text":"hard_constraints(problem::AbstractProblem) -> Vector{LocalConstraint}\n\nThe hard constraints of the problem. Once the hard constraints are violated, the energy goes to infinity.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.is_matching-Tuple{SimpleGraph, Any}","page":"Reference","title":"ProblemReductions.is_matching","text":"is_matching(graph::SimpleGraph, config)\n\nReturns true if config is a valid matching on graph, and false if a vertex is double matched. config is a vector of boolean variables, which has one to one correspondence with edges(graph).\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.is_maximal_independent_set-Tuple{SimpleGraph, Any}","page":"Reference","title":"ProblemReductions.is_maximal_independent_set","text":"is_maximal_independent_set(g::SimpleGraph, config)\n\nReturn true if config (a vector of boolean numbers as the mask of vertices) is a maximal independent set of graph g.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.is_set_covering-Tuple{SetCovering, Any}","page":"Reference","title":"ProblemReductions.is_set_covering","text":"is_set_covering(c::SetCovering, config)\n\nReturn true if config (a vector of boolean numbers as the mask of sets) is a set covering of sets.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.is_set_packing-Union{Tuple{ST}, Tuple{AbstractVector{ST}, Any}} where ST","page":"Reference","title":"ProblemReductions.is_set_packing","text":"is_set_packing(sets::AbstractVector, config)\n\nReturn true if config (a vector of boolean numbers as the mask of sets) is a set packing of sets.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.is_vertex_coloring-Tuple{SimpleGraph, Any}","page":"Reference","title":"ProblemReductions.is_vertex_coloring","text":"is_vertex_coloring(graph::SimpleGraph, config)\n\nReturns true if the coloring specified by config is a valid one, i.e. does not violate the contraints of vertices of an edges having different colors.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.is_vertex_covering-Tuple{SimpleGraph, Any}","page":"Reference","title":"ProblemReductions.is_vertex_covering","text":"is_vertex_covering(graph::SimpleGraph, config)\n\nreturn true if the vertex configuration config is a vertex covering of the graph. Our judgement is based on the fact that for each edge, at least one of its vertices is selected.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.is_weighted-Tuple{ConstraintSatisfactionProblem}","page":"Reference","title":"ProblemReductions.is_weighted","text":"is_weighted(problem::ConstraintSatisfactionProblem) -> Bool\n\nCheck if the problem is weighted. Returns true if the problem has non-unit weights.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.local_energy","page":"Reference","title":"ProblemReductions.local_energy","text":"local_energy(::Type{<:ConstraintSatisfactionProblem{T}}, constraint::LocalConstraint, config) -> T\n\nThe local energy of the constraint given the configuration config.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.num_flavors-Tuple{GT} where GT<:AbstractProblem","page":"Reference","title":"ProblemReductions.num_flavors","text":"num_flavors(::Type{<:AbstractProblem}) -> Int\n\nReturns the number of flavors (domain) of a degree of freedom.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.num_variables-Tuple{AbstractProblem}","page":"Reference","title":"ProblemReductions.num_variables","text":"num_variables(problem::AbstractProblem) -> Int\n\nThe number of variables in the computational problem.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.onehotv-Union{Tuple{C}, Tuple{S}, Tuple{N}, Tuple{Type{StaticElementVector{N, S, C}}, Any, Any}} where {N, S, C}","page":"Reference","title":"ProblemReductions.onehotv","text":"onehotv(::Type{<:StaticElementVector}, i, v)\nonehotv(::Type{<:StaticBitVector, i)\n\nReturns a static element vector, with the value at location i being v (1 if not specified).\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.paint_shop_coloring_from_config-Union{Tuple{LT}, Tuple{PaintShop{LT}, Any}} where LT","page":"Reference","title":"ProblemReductions.paint_shop_coloring_from_config","text":"paint_shop_coloring_from_config(p::PaintShop, config)\n\nReturns a valid painting from the paint shop configuration (given by the configuration solvers). The config is a sequence of 0 and 1, where 0 means painting the first appearence of a car in red,  and 1 means painting the first appearence of a car in blue.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.problem_size","page":"Reference","title":"ProblemReductions.problem_size","text":"problem_size(problem::AbstractProblem) -> NamedTuple\n\nThe size of the computational problem, which is problem dependent.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.problem_size-Tuple{SetCovering}","page":"Reference","title":"ProblemReductions.problem_size","text":"Defined as the number of sets.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.reduce_size-Union{Tuple{TA}, Tuple{Type{TA}, AbstractProblem}} where TA<:AbstractProblem","page":"Reference","title":"ProblemReductions.reduce_size","text":"reduce_size(::Type{T}, ::Type{S}, size)\n\nReturn the size of the target problem T after reducing the source problem S to T.\n\nnote: Note\nThe problem size measure is problem dependent. Please check problem_size for the problem size measure.\n\nArguments\n\nT: The target problem type.\nS: The source problem type.\nsize: The size of the source problem.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.reduceto","page":"Reference","title":"ProblemReductions.reduceto","text":"reduceto(problem_type::Type{<:AbstractProblem}, problem::AbstractProblem) -> AbstractReductionResult\nreduceto(path::ReductionPath, problem::AbstractProblem) -> ConcatenatedReduction\n\nReduce the problem problem to a target problem. If the target problem is a single problem type, reduce the problem problem to a target problem of type. Then the result is an instance of AbstractReductionResult. Otherwise, if the target problem is a reduction path, implement a reduction path on a problem. Then the result is a ConcatenatedReduction instance.\n\nArguments\n\nproblem_type::Type{<:AbstractProblem} or path::ReductionPath: The target problem type or a reduction path.\nproblem::AbstractProblem: The original problem.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.reduction_graph-Tuple{}","page":"Reference","title":"ProblemReductions.reduction_graph","text":" reduction_graph()\n\nReturns a ReductionGraph instance from the reduction rules defined with method reduceto.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.reduction_paths-Union{Tuple{S}, Tuple{T}, Tuple{Type{S}, Type{T}}} where {T<:AbstractProblem, S<:AbstractProblem}","page":"Reference","title":"ProblemReductions.reduction_paths","text":"reduction_paths([rg::ReductionGraph, ]S::Type, T::Type)\n\nFind all reduction paths from problem type S to problem type T. Returns a list of paths, where each path is a sequence of problem types.\n\nArguments\n\nrg::ReductionGraph: The reduction graph of type ReductionGraph.\nS::Type: The source problem type.\nT::Type: The target problem type.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.satisfiable-Union{Tuple{T}, Tuple{BoolVar{T}, AbstractDict{T}}} where T","page":"Reference","title":"ProblemReductions.satisfiable","text":"satisfiable(expr, config::AbstractDict{T}) where T\n\nCheck if the boolean expression expr is satisfied by the configuration config.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.set_weights","page":"Reference","title":"ProblemReductions.set_weights","text":"set_weights(problem::ConstraintSatisfactionProblem, weights) -> ConstraintSatisfactionProblem\n\nChange the weights for the problem and return a new problem instance.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.spinglass_gadget-Tuple{Val{:arraymul}}","page":"Reference","title":"ProblemReductions.spinglass_gadget","text":"spinglass_gadget(::Val{:arraymul})\n\nThe array multiplier gadget.\n\n    s_{i+1,j-1}  p_i\n           \\     |\n        q_j ------------ q_j\n                 |\n    c_{i,j} ------------ c_{i-1,j}\n                 |     \\\n                 p_i     s_{i,j} \n\nvariables: pi, qj, pq, c{i-1,j}, s{i+1,j-1}, c{i,j}, s{i,j}\nconstraints: 2 * c{i,j} + s{i,j} = pi qj + c{i-1,j} + s{i+1,j-1}\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.target_problem","page":"Reference","title":"ProblemReductions.target_problem","text":"target_problem(res::AbstractReductionResult) -> AbstractProblem\n\nReturn the target problem of the reduction result.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.truth_table-Tuple{LogicGadget}","page":"Reference","title":"ProblemReductions.truth_table","text":"truth_table(ga::LogicGadget; variables=1:num_variables(ga.problem), solver=BruteForce())\n\nCompute the truth table of a logic gadget.\n\nArguments\n\nga::LogicGadget: the logic gadget.\n\nKeyword Arguments\n\nvariables::Vector{Int}: the variables to be displayed.\nsolver::AbstractSolver: the solver to be used.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.variables","page":"Reference","title":"ProblemReductions.variables","text":"variables(problem::AbstractProblem) -> Vector\n\nThe degrees of freedoms in the computational problem. e.g. for the maximum independent set problems, they are the indices of vertices: 1, 2, 3..., while for the max cut problem, they are the edges.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.weight_type-Tuple{AbstractProblem}","page":"Reference","title":"ProblemReductions.weight_type","text":"weight_type(problem::AbstractProblem) -> Type\n\nThe data type of the weights in the computational problem.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.weights","page":"Reference","title":"ProblemReductions.weights","text":"weights(problem::ConstraintSatisfactionProblem) -> Vector\n\nThe weights of the constraints in the problem.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.@bools-Tuple{Vararg{Symbol}}","page":"Reference","title":"ProblemReductions.@bools","text":"@bools(syms::Symbol...)\n\nCreate some boolean variables of type BoolVar in current scope that can be used in create a CNF.\n\nExample\n\nUnder Development\n\n\n\n\n\n","category":"macro"},{"location":"ref/#ProblemReductions.@bv_str-Tuple{Any}","page":"Reference","title":"ProblemReductions.@bv_str","text":"Constructing a static bit vector.\n\n\n\n\n\n","category":"macro"},{"location":"ref/#ProblemReductions.@circuit-Tuple{Any}","page":"Reference","title":"ProblemReductions.@circuit","text":"@circuit circuit_expr\n\nConstruct a circuit expression from a block of assignments.\n\nExamples\n\njulia> @circuit begin\n        x = a ∨ b\n        y = x ∧ c\n       end\nCircuit:\n| x = ∨(a, b)\n| y = ∧(x, c)\n\n\n\n\n\n","category":"macro"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = ProblemReductions","category":"page"},{"location":"#ProblemReductions","page":"Home","title":"ProblemReductions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is the documentation for the open source package ProblemReductions, a package for the reduction (or transformation) between computational hard problems. Although the reduction is a common concept in the field of computational complexity, every textbook on this topic defines its own set of problems and reduction rules. Unfortunately, these rules are not directly accessible to the public, especially for people in fields such as quantum many-body physics and statistical physics. This package aims to collect a set of well-known problems and their reductions in one place, and provide a unified interface to access them. We hope this will lower the barrier for researchers to enter this fascinating field.","category":"page"},{"location":"#Framework","page":"Home","title":"Framework","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ProblemReductions defines a set of computational hard problems and the reduction rules between them. In the following diagram, we use an arrow pointing from problem A to problem B to indicate that there is a reduction rule from problem A to problem B.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"The reduction rules induce a directed graph, called the reduction graph, where the nodes are the problems and the edges are the reductions. Problem A can be reduced to problem B if and only if there is a path from A to B. This reduction may consist of multiple steps, and the reduction path may not be unique.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The following example shows how to use the package to solve a simple factoring problem  times  = 3 by reducing it to an Ising model.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using ProblemReductions\nfactoring = Factoring(2, 1, 3)  # define the factoring problem\npaths = reduction_paths(Factoring, SpinGlass);\nlength(paths)   # you may find multiple reduction paths\nres = reduceto(paths[1], factoring); # perform the reduction\nproblem_size(target_problem(res))","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Factoring problem is defined with two inputs of bit width 2 and 1, respectively. We first query the reduction paths from the Factoring problem to the SpinGlass problem using reduction_paths, and find multiple paths. Each path is a ReductionPath instance. We pick one reduction path and perform the reduction using reduceto. The result is a ConcatenatedReduction instance, which contains not only the target problem, but also the intermediate reductions in the reduction path. The target problem is an Ising model with 25 spins, which is exactly solvable using the BruteForce method implemented in findbest:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> sol = findbest(target_problem(res), BruteForce()); # solve the target problem\n\njulia> extract_solution.(Ref(res), sol) # extract the solution to the original problem\n1-element Vector{Vector{Int64}}:\n [1, 1, 1]","category":"page"},{"location":"","page":"Home","title":"Home","text":"The solution to the original problem is extracted using extract_solution. Note that the findbest funciton returns a set of equally good solutions, so broadcasting is used here.","category":"page"},{"location":"#Model-Problems","page":"Home","title":"Model Problems","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A model problem is a subclass of AbstractProblem that defines the energy function of a computational problem. Facts affecting the computational complexity classification of the problem also include the topology of the problem and the domain of the variables.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The required interfaces are:","category":"page"},{"location":"","page":"Home","title":"Home","text":"variables: The degrees of freedoms in the problem.   e.g. for the maximum independent set problems, they are the indices of vertices: 1, 2, 3...,   while for the max cut problem, they are the edges.\nflavors: A vector of integers as the flavors (or domain) of a degree of freedom.   e.g. for the maximum independent set problems, the flavors are [0, 1], where 0 means the vertex is not in the set and 1 means the vertex is in the set.\nweights: Energies associated with constraints.\nenergy: Energy of a given configuration.\nproblem_size: The size of the problem, which is the number of variables.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Optional functions include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"num_variables: The number of variables in the problem.\nnum_flavors: The number of flavors in the problem.\nset_weights: Change the weights for the problem and return a new problem instance.\nweight_type: The data type of weights.\nfindbest: Find the best configurations in the computational problem.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The following code lists all problems defined in ProblemReductions:","category":"page"},{"location":"","page":"Home","title":"Home","text":"ProblemReductions.concrete_subtypes(AbstractProblem)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Please check Problems zoo for more details.","category":"page"},{"location":"#Graph-Topology","page":"Home","title":"Graph Topology","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Model problems are often defined on graphs. When limiting a model problem to a specific graph topology, the hardness of the problem can be drastically different. To handle this, we define the following graph types:","category":"page"},{"location":"","page":"Home","title":"Home","text":"SimpleGraph: A simple graph is an undirected graph with no self-loops or multiple edges between the same pair of vertices.\nHyperGraph: A hypergraph is a generalization of a graph in which an edge can connect any number of vertices.\nUnitDiskGraph: A unit disk graph is a graph in which vertices are placed in the Euclidean plane and edges are drawn between vertices that are within a fixed distance of each other. Similarly, we have an alias GridGraph for unit disk graphs with integer coordinates (i.e. vertices are placed on a grid).","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"To define a graph topology, the minimum required functions are: vertices and edges. More interfaces are specified in the Graphs package.","category":"page"},{"location":"#Reduction-Rules","page":"Home","title":"Reduction Rules","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A problem reduction rule is a function that reduces a problem to another problem. By solving the target problem, we can extract the solution to the original problem. The reduction rule is defined as a function that takes an instance of the original problem and returns an AbstractReductionResult instance of the target problem.","category":"page"},{"location":"","page":"Home","title":"Home","text":"reduceto: Reduce the source problem to a target problem of a specific type. Returns an AbstractReductionResult instance, which contains the target problem.\ntarget_problem: Return the target problem of the reduction result.\nextract_solution: Extract the solution to the target problem back to the original problem.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Optional functions include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"extract_multiple_solutions: Extract a set of solutions to the target problem back to the original problem. You may want to implement this when you want to make extracting multiple solutions faster.\nreduce_size: Infer the size of the target problem from the source problem size.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The reduction_graph function returns the reduction graph of the problems that induced by the reduction rules defined in ProblemReductions:","category":"page"},{"location":"","page":"Home","title":"Home","text":"rgraph = ProblemReductions.reduction_graph()\nrgraph.graph\nrgraph.nodes","category":"page"},{"location":"","page":"Home","title":"Home","text":"The number of rules is the same as the number of edges in the output graph. Both the problem set, and the reduction rules are designed to be extensible, so that users can easily add new problems and reductions to the package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"It is worth noting that the reduction graph changes whenever there is a new reduceto function is added, regardless it is in this package or by users. This is because the reduction graph checks all method tables of the reduceto function, and will automatically add new nodes and edges when a new problem type or reduction method is added.","category":"page"},{"location":"rules/independentset_setpacking/#Independent-Set-Set-Packing","page":"Independent Set -> Set Packing","title":"Independent Set -> Set Packing","text":"","category":"section"},{"location":"rules/independentset_setpacking/","page":"Independent Set -> Set Packing","title":"Independent Set -> Set Packing","text":"In this tutorial, we will demonstrate how to reduce the IndependentSet problem to the SetPacking problem and how to extract solutions back to the original problem.","category":"page"},{"location":"rules/independentset_setpacking/#Reduction-Framework","page":"Independent Set -> Set Packing","title":"Reduction Framework","text":"","category":"section"},{"location":"rules/independentset_setpacking/","page":"Independent Set -> Set Packing","title":"Independent Set -> Set Packing","text":"Given an undirected graph G=(VE) and parameter k, we can have an instance of the IndependentSet problem (G k). we aim to generate a corresponding SetPacking instance (U S k) (where U is the union set, S is the set of subsets and parameter k is the required set packing size).","category":"page"},{"location":"rules/independentset_setpacking/","page":"Independent Set -> Set Packing","title":"Independent Set -> Set Packing","text":"Step-0: k are the same;\nStep-1: Each edge (uv)in E -> Create an element x_uv in U;\nStep-2: Each vertex v in V -> Create a subset S_uv(uv)in E .","category":"page"},{"location":"rules/independentset_setpacking/","page":"Independent Set -> Set Packing","title":"Independent Set -> Set Packing","text":"It can be proven that:","category":"page"},{"location":"rules/independentset_setpacking/","page":"Independent Set -> Set Packing","title":"Independent Set -> Set Packing","text":"The instance (Gk) is an yes-instance if and only if generated (USk) is an yes-instance;\nThis transformation is within polynomial time.","category":"page"},{"location":"rules/independentset_setpacking/#Construct-Reduction","page":"Independent Set -> Set Packing","title":"Construct Reduction","text":"","category":"section"},{"location":"rules/independentset_setpacking/","page":"Independent Set -> Set Packing","title":"Independent Set -> Set Packing","text":"We can firstly define a IndependentSet problem over a simple graph with 4 vertices.","category":"page"},{"location":"rules/independentset_setpacking/","page":"Independent Set -> Set Packing","title":"Independent Set -> Set Packing","text":"using ProblemReductions, Graphs\ngraph = SimpleGraph(4)\nfor (i, j) in [(1, 2), (1, 3), (3, 4), (2, 3)]\n    add_edge!(graph, i, j)\nend\nIS = IndependentSet(graph)","category":"page"},{"location":"rules/independentset_setpacking/","page":"Independent Set -> Set Packing","title":"Independent Set -> Set Packing","text":"Then the reduction ReductionIndependentSetToSetPacking can be easily constructed by the reduceto function.","category":"page"},{"location":"rules/independentset_setpacking/","page":"Independent Set -> Set Packing","title":"Independent Set -> Set Packing","text":"result = reduceto(SetPacking, IS)","category":"page"},{"location":"rules/independentset_setpacking/","page":"Independent Set -> Set Packing","title":"Independent Set -> Set Packing","text":"The target SetPacking problem can be accessed by the target field:","category":"page"},{"location":"rules/independentset_setpacking/","page":"Independent Set -> Set Packing","title":"Independent Set -> Set Packing","text":"SP = result.target","category":"page"},{"location":"rules/independentset_setpacking/#Extract-Solutions","page":"Independent Set -> Set Packing","title":"Extract Solutions","text":"","category":"section"},{"location":"rules/independentset_setpacking/","page":"Independent Set -> Set Packing","title":"Independent Set -> Set Packing","text":"We can extract solutions from the target SetPacking problem either by extracting individual solutions via extract_solution or extracting mutilple solutions via extract_multiple_solutions.","category":"page"},{"location":"rules/independentset_setpacking/","page":"Independent Set -> Set Packing","title":"Independent Set -> Set Packing","text":"sol_SP = findbest(SP, BruteForce())\nsol_extract_single = Set( unique( extract_solution.(Ref(result), sol_SP) ) )\nsol_extract_mutilple = Set( extract_multiple_solutions(result, sol_SP) )","category":"page"},{"location":"rules/independentset_setpacking/","page":"Independent Set -> Set Packing","title":"Independent Set -> Set Packing","text":"We can find that these extracted solutions indeed match with the solutions to the original IndependentSet problem.","category":"page"},{"location":"rules/independentset_setpacking/","page":"Independent Set -> Set Packing","title":"Independent Set -> Set Packing","text":"sol_IS = findbest(IS, BruteForce())","category":"page"}]
}
