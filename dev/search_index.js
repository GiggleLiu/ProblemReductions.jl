var documenterSearchIndex = {"docs":
[{"location":"generated/material_compute/","page":"Surface Programmable Materials","title":"Surface Programmable Materials","text":"EditURL = \"../../../examples/material_compute.jl\"","category":"page"},{"location":"generated/material_compute/#Surface-Programmable-Materials","page":"Surface Programmable Materials","title":"Surface Programmable Materials","text":"","category":"section"},{"location":"generated/material_compute/","page":"Surface Programmable Materials","title":"Surface Programmable Materials","text":"This is an example to be written.","category":"page"},{"location":"generated/material_compute/","page":"Surface Programmable Materials","title":"Surface Programmable Materials","text":"using ProblemReductions","category":"page"},{"location":"generated/material_compute/","page":"Surface Programmable Materials","title":"Surface Programmable Materials","text":"","category":"page"},{"location":"generated/material_compute/","page":"Surface Programmable Materials","title":"Surface Programmable Materials","text":"This page was generated using Literate.jl.","category":"page"},{"location":"topology/#Graph-Topology","page":"Graph Topology","title":"Graph Topology","text":"","category":"section"},{"location":"topology/","page":"Graph Topology","title":"Graph Topology","text":"SimpleGraph: A simple graph is an undirected graph with no self-loops or multiple edges between the same pair of vertices.\nHyperGraph: A hypergraph is a generalization of a graph in which an edge can connect any number of vertices.\nUnitDiskGraph: A unit disk graph is a graph in which vertices are placed in the Euclidean plane and edges are drawn between vertices that are within a fixed distance of each other.\nGridGraph: A grid graph is a graph in which vertices are placed on a grid and edges are drawn between vertices that are adjacent in the grid.","category":"page"},{"location":"topology/#Interfaces","page":"Graph Topology","title":"Interfaces","text":"","category":"section"},{"location":"topology/","page":"Graph Topology","title":"Graph Topology","text":"The minimum required functions for a graph are:","category":"page"},{"location":"topology/","page":"Graph Topology","title":"Graph Topology","text":"vertices: The vertices in the graph.\nedges: The edges in the graph.","category":"page"},{"location":"topology/","page":"Graph Topology","title":"Graph Topology","text":"Optional functions include:","category":"page"},{"location":"topology/","page":"Graph Topology","title":"Graph Topology","text":"ne: The number of edges in the graph.\nnv: The number of vertices in the graph.","category":"page"},{"location":"topology/","page":"Graph Topology","title":"Graph Topology","text":"These interfaces are defined in the Graphs package.","category":"page"},{"location":"models/SpinGlass/#Spin-Glass","page":"Spin Glass","title":"Spin Glass","text":"","category":"section"},{"location":"models/SpinGlass/#Problem-Definition","page":"Spin Glass","title":"Problem Definition","text":"","category":"section"},{"location":"models/SpinGlass/","page":"Spin Glass","title":"Spin Glass","text":"Spin Glass is a type of disordered magnetic system that exhibits a glassy behavior. The Hamiltonian of the system on a simple graph G is given by","category":"page"},{"location":"models/SpinGlass/","page":"Spin Glass","title":"Spin Glass","text":"H(G sigma) = sum_(ij) in E(G) J_ij sigma_i sigma_j","category":"page"},{"location":"models/SpinGlass/","page":"Spin Glass","title":"Spin Glass","text":"where J_ij is the coupling strength between spins i and j and sigma_i is the spin variable that can take values in -1 1.","category":"page"},{"location":"models/SpinGlass/","page":"Spin Glass","title":"Spin Glass","text":"This definition naturally extends to the case of a HyperGraph.","category":"page"},{"location":"models/SpinGlass/#Interfaces","page":"Spin Glass","title":"Interfaces","text":"","category":"section"},{"location":"models/SpinGlass/","page":"Spin Glass","title":"Spin Glass","text":"To define a SpinGlass problem, we need to specify the graph, the coupling strength J_ij, and possibly the external field h_i for each spin i.","category":"page"},{"location":"models/SpinGlass/","page":"Spin Glass","title":"Spin Glass","text":"using ProblemReductions, ProblemReductions.Graphs\n\ngraph = smallgraph(:petersen)\nJ = rand([1, -1], ne(graph))  # coupling strength\nh = rand([1, -1], nv(graph))  # external field\nspinglass = SpinGlass(graph, J, h)  # Define a spin glass problem","category":"page"},{"location":"models/SpinGlass/","page":"Spin Glass","title":"Spin Glass","text":"Here, we also define an external field h_i for each spin i. The resulting spin glass problem is defined on a HyperGraph, where external fields are associated with hyperedges connecting single spins.","category":"page"},{"location":"models/SpinGlass/","page":"Spin Glass","title":"Spin Glass","text":"The required functions, variables, flavors, and evaluate, and optional functions, findbest, are implemented for the spin glass problem.","category":"page"},{"location":"models/SpinGlass/","page":"Spin Glass","title":"Spin Glass","text":"variables(spinglass)  # degrees of freedom\nflavors(spinglass)  # flavors of the spins\nevaluate(spinglass, [0, 1, 1, 0, 1, 1, 1, 0, 0, 1])  # energy of a configuration\nfindbest(spinglass, BruteForce())  # solve the problem with brute force","category":"page"},{"location":"models/#Model-Problem","page":"Model Problem","title":"Model Problem","text":"","category":"section"},{"location":"models/","page":"Model Problem","title":"Model Problem","text":"A model problem is a subclass of AbstractProblem that defines the energy function of a computational problem. Facts affecting the computational complexity classification of the problem also include the topology of the problem and the domain of the variables.","category":"page"},{"location":"models/#Interfaces","page":"Model Problem","title":"Interfaces","text":"","category":"section"},{"location":"models/","page":"Model Problem","title":"Model Problem","text":"Required functions include:","category":"page"},{"location":"models/","page":"Model Problem","title":"Model Problem","text":"variables: The degrees of freedoms in the problem.   e.g. for the maximum independent set problems, they are the indices of vertices: 1, 2, 3...,   while for the max cut problem, they are the edges.\nflavors: A vector of integers as the flavors (or domain) of a degree of freedom.   e.g. for the maximum independent set problems, the flavors are [0, 1], where 0 means the vertex is not in the set and 1 means the vertex is in the set.\nparameters: Energies associated with terms.\nevaluate: Evaluate the energy of a given configuration.","category":"page"},{"location":"models/","page":"Model Problem","title":"Model Problem","text":"Optional functions include:","category":"page"},{"location":"models/","page":"Model Problem","title":"Model Problem","text":"num_variables: The number of variables in the problem.\nnum_flavors: The number of flavors in the problem.\nset_parameters: Change the parameters for the problem and return a new problem instance.\nparameter_type: The data type of parameters.\nfindbest: Find the best configurations in the computational problem.","category":"page"},{"location":"rules/spinglass_sat/#CircuitSAT-SpinGlass","page":"CircuitSAT -> SpinGlass","title":"CircuitSAT -> SpinGlass","text":"","category":"section"},{"location":"rules/spinglass_sat/","page":"CircuitSAT -> SpinGlass","title":"CircuitSAT -> SpinGlass","text":"In this tutorial, we will demonstrate how to use the Spinglass model to solve the circuit satisfiability problem.","category":"page"},{"location":"rules/spinglass_sat/","page":"CircuitSAT -> SpinGlass","title":"CircuitSAT -> SpinGlass","text":"We first define a simple Circuit using the @circuit macro. And then we convert the circuit to a CircuitSAT problem.","category":"page"},{"location":"rules/spinglass_sat/","page":"CircuitSAT -> SpinGlass","title":"CircuitSAT -> SpinGlass","text":"using ProblemReductions\n\ncircuit = @circuit begin\n    c = x ∧ y\n    d = x ∨ (¬c ∧ ¬z)\nend\ncircuitsat = CircuitSAT(circuit)\nvariables(circuitsat)\ncircuitsat.symbols","category":"page"},{"location":"rules/spinglass_sat/","page":"CircuitSAT -> SpinGlass","title":"CircuitSAT -> SpinGlass","text":"The resulting circuitsat expands the expression to a list of simple clauses. The variables are mapped to integers that pointing to the symbols that stored in the symbols field.","category":"page"},{"location":"rules/spinglass_sat/","page":"CircuitSAT -> SpinGlass","title":"CircuitSAT -> SpinGlass","text":"The we can convert the circuit to a SpinGlass problem using the reduceto function.","category":"page"},{"location":"rules/spinglass_sat/","page":"CircuitSAT -> SpinGlass","title":"CircuitSAT -> SpinGlass","text":"result = reduceto(SpinGlass, circuitsat)","category":"page"},{"location":"rules/spinglass_sat/","page":"CircuitSAT -> SpinGlass","title":"CircuitSAT -> SpinGlass","text":"The resulting result is a ReductionCircuitToSpinGlass instance that contains the spin glass problem.","category":"page"},{"location":"rules/spinglass_sat/","page":"CircuitSAT -> SpinGlass","title":"CircuitSAT -> SpinGlass","text":"With the result instance, we can define a logic gadget that maps the spin glass variables to the circuit variables.","category":"page"},{"location":"rules/spinglass_sat/","page":"CircuitSAT -> SpinGlass","title":"CircuitSAT -> SpinGlass","text":"indexof(x) = findfirst(==(findfirst(==(x), circuitsat.symbols)), result.variables)\ngadget = LogicGadget(result.spinglass, indexof.([:x, :y, :z]), [indexof(:d)])\ntb = truth_table(gadget; variables=circuitsat.symbols[result.variables])","category":"page"},{"location":"rules/spinglass_sat/","page":"CircuitSAT -> SpinGlass","title":"CircuitSAT -> SpinGlass","text":"The gadget is a LogicGadget instance that maps the spin glass variables to the circuit variables. The truth_table function generates the truth table of the gadget.","category":"page"},{"location":"generated/dining/","page":"Dining with Friends(developing yet)","title":"Dining with Friends(developing yet)","text":"EditURL = \"../../../examples/dining.jl\"","category":"page"},{"location":"generated/dining/#Dining-with-Friends(developing-yet)","page":"Dining with Friends(developing yet)","title":"Dining with Friends(developing yet)","text":"","category":"section"},{"location":"generated/dining/","page":"Dining with Friends(developing yet)","title":"Dining with Friends(developing yet)","text":"","category":"page"},{"location":"generated/dining/#Inviting-friends-to-dinner-cracking-a-bank-encryption-system","page":"Dining with Friends(developing yet)","title":"Inviting friends to dinner > cracking a bank encryption system","text":"","category":"section"},{"location":"generated/dining/","page":"Dining with Friends(developing yet)","title":"Dining with Friends(developing yet)","text":"Using this package, we could showcase the problem how inviting friends to a dinner party is harder than cracking a bank encryption system.Let's introduce some background knowledge.","category":"page"},{"location":"generated/dining/#Intor-to-RSA","page":"Dining with Friends(developing yet)","title":"Intor to RSA","text":"","category":"section"},{"location":"generated/dining/","page":"Dining with Friends(developing yet)","title":"Dining with Friends(developing yet)","text":"RSA is a public-key cryptosystem. It's widely used in encryption algorithm that helps secure bank transactions and communications. Here's the Introduction->RSA encryption. Easily explained, there are public key (ne) and private key(nd). The attacker needs to factorize the n, a product of two large prime numbers. So the security of RSA comes from factoring problem.","category":"page"},{"location":"generated/dining/#Factoring-problem","page":"Dining with Friends(developing yet)","title":"Factoring problem","text":"","category":"section"},{"location":"generated/dining/","page":"Dining with Friends(developing yet)","title":"Dining with Friends(developing yet)","text":"The factoring problem is to find the prime factors of a composite number. It's a pratically hard problem. Generally, the input size in RSA is 2048 bits. Consider two algorithms to solve it: General number field sieve(GNFS, a good algorithm in factoring) and  Brute force.","category":"page"},{"location":"generated/dining/","page":"Dining with Friends(developing yet)","title":"Dining with Friends(developing yet)","text":"Algorithm Time complexity Operations Time (10^12 ops/s)\nGNFS O(e^(log n)^13(log log n)^23) 2^112  7 times 10^20 years\nBrute force O(sqrtn) 2^1024 57 times 10^228 years","category":"page"},{"location":"generated/dining/","page":"Dining with Friends(developing yet)","title":"Dining with Friends(developing yet)","text":"Both are way longer than the age of our universe.","category":"page"},{"location":"generated/dining/","page":"Dining with Friends(developing yet)","title":"Dining with Friends(developing yet)","text":"So basically, RSA relies on factoring and if we could reduce factoring to maxcut problem, we could show that inviting friends to a dinner party is harder than cracking a bank encryption system. Next part, I'll reduce factoring to the maxcut by: Factoring -> Circuit Sat -> SpinGlass -> MaxCut.","category":"page"},{"location":"generated/dining/","page":"Dining with Friends(developing yet)","title":"Dining with Friends(developing yet)","text":"","category":"page"},{"location":"generated/dining/#Factoring-MaxCut","page":"Dining with Friends(developing yet)","title":"Factoring -> MaxCut","text":"","category":"section"},{"location":"generated/dining/","page":"Dining with Friends(developing yet)","title":"Dining with Friends(developing yet)","text":"using ProblemReductions, Graphs, LuxorGraphPlot","category":"page"},{"location":"generated/dining/","page":"Dining with Friends(developing yet)","title":"Dining with Friends(developing yet)","text":"For a given number n, we could create a factoring problem.","category":"page"},{"location":"generated/dining/#Create-a-factoring-problem","page":"Dining with Friends(developing yet)","title":"Create a factoring problem","text":"","category":"section"},{"location":"generated/dining/#reduce-the-factoring-to-the-circuit-Sat-problem","page":"Dining with Friends(developing yet)","title":"reduce the factoring to the circuit Sat problem","text":"","category":"section"},{"location":"generated/dining/","page":"Dining with Friends(developing yet)","title":"Dining with Friends(developing yet)","text":"could I visualize this circuit Sat?","category":"page"},{"location":"generated/dining/#reduce-the-circuit-Sat-problem-to-the-SpinGlass-problem","page":"Dining with Friends(developing yet)","title":"reduce the circuit Sat problem to the SpinGlass problem","text":"","category":"section"},{"location":"generated/dining/","page":"Dining with Friends(developing yet)","title":"Dining with Friends(developing yet)","text":"Visualize this SpinGlass problem","category":"page"},{"location":"generated/dining/#reduce-the-SpinGlass-problem-to-the-MaxCut-problem","page":"Dining with Friends(developing yet)","title":"reduce the SpinGlass problem to the MaxCut problem","text":"","category":"section"},{"location":"generated/dining/","page":"Dining with Friends(developing yet)","title":"Dining with Friends(developing yet)","text":"Visualize this MaxCut problem and explain how the maxcut problem represents inviting friends to a dinner party","category":"page"},{"location":"generated/dining/","page":"Dining with Friends(developing yet)","title":"Dining with Friends(developing yet)","text":"","category":"page"},{"location":"generated/dining/","page":"Dining with Friends(developing yet)","title":"Dining with Friends(developing yet)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"ref/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"ref/","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"ref/","page":"Reference","title":"Reference","text":"Modules = [ProblemReductions]","category":"page"},{"location":"ref/#ProblemReductions.AbstractProblem","page":"Reference","title":"ProblemReductions.AbstractProblem","text":"AbstractProblem\n\nThe abstract base type of computational problems.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.AbstractReductionResult","page":"Reference","title":"ProblemReductions.AbstractReductionResult","text":"abstract type AbstractReductionResult\n\nThe base type for a reduction result.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.BoolVar","page":"Reference","title":"ProblemReductions.BoolVar","text":"BoolVar{T}\nBoolVar(name, neg)\n\nBoolean variable for constructing CNF clauses.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.BruteForce","page":"Reference","title":"ProblemReductions.BruteForce","text":"struct BruteForce\n\nA brute force method to find the best configuration of a problem.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.CNF","page":"Reference","title":"ProblemReductions.CNF","text":"CNF{T}\nCNF(clauses)\n\nBoolean expression in conjunctive normal form. clauses is a vector of CNFClause, if and only if all clauses are satisfied, this CNF is satisfied.\n\nExample\n\nUnder development\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.CNFClause","page":"Reference","title":"ProblemReductions.CNFClause","text":"CNFClause{T}\nCNFClause(vars)\n\nA clause in CNF, its value is the logical or of vars, where vars is a vector of BoolVar.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.Circuit","page":"Reference","title":"ProblemReductions.Circuit","text":"struct Circuit\n\nA circuit expression is a sequence of assignments.\n\nFields\n\nexprs::Vector{Assignment}: The assignments in the circuit.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.CircuitSAT","page":"Reference","title":"ProblemReductions.CircuitSAT","text":"struct CircuitSAT <: AbstractProblem\n\nCircuit satisfiability problem, where the goal is to find an assignment that satisfies the circuit.\n\nFields\n\ncircuit::Circuit: The circuit expression in SSA form.\nsymbols::Vector{Symbol}: The variables in the circuit.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.Coloring","page":"Reference","title":"ProblemReductions.Coloring","text":"struct Coloring{K, WT<:(AbstractVector)} <: AbstractProblem\n\nColoring{K}(graph; weights=UnitWeight(nv(graph)))\n\nThe Vertex Coloring problem.\n\nPositional arguments\n\ngraph is the problem graph.\nweights are associated with the edges of the graph, default to UnitWeight(ne(graph)).\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.ConcatenatedReduction","page":"Reference","title":"ProblemReductions.ConcatenatedReduction","text":"struct ConcatenatedReduction\n\nA sequence of reductions.\n\nFields\n\nsequence::Vector{Any}: The sequence of reductions.\ncomplexity::Int: The complexity of the reduction.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.DominatingSet","page":"Reference","title":"ProblemReductions.DominatingSet","text":"struct DominatingSet{GT<:Graphs.AbstractGraph} <: AbstractProblem\n\nDominatingSet(graph; weights=UnitWeight())\n\nThe dominating set problem.\n\nPositional arguments\n\ngraph is the problem graph.\n\nWe don't have weights for this problem.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.GridGraph","page":"Reference","title":"ProblemReductions.GridGraph","text":"struct GridGraph <: Graphs.AbstractGraph{Int64}\n\nA grid graph is a graph in which the vertices are arranged in a grid and two vertices are connected by an edge if and only if they are adjacent in the grid.\n\nFields\n\ngrid::BitMatrix: a matrix of booleans, where true indicates the presence of an edge.\nradius::Float64: the radius of the unit disk\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.HyperGraph","page":"Reference","title":"ProblemReductions.HyperGraph","text":"struct HyperGraph <: Graphs.AbstractGraph{Int64}\n\nA hypergraph is a generalization of a graph in which an edge can connect any number of vertices.\n\nFields\n\nn::Int: the number of vertices\nedges::Vector{Vector{Int}}: a vector of vectors of integers, where each vector represents a hyperedge connecting the vertices with the corresponding indices.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.IndependentSet","page":"Reference","title":"ProblemReductions.IndependentSet","text":"struct IndependentSet{GT<:Graphs.AbstractGraph, WT<:(AbstractVector)} <: AbstractProblem\n\nThe independent set problem in graph theory.\n\nPositional arguments\n\ngraph is the problem graph.\nweights are associated with the vertices of the graph.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.KSatisfiability","page":"Reference","title":"ProblemReductions.KSatisfiability","text":"struct KSatisfiability{K, T} <: ProblemReductions.AbstractSatisfiabilityProblem{T}\n\nThe satisfiability problem for k-SAT, where the goal is to find an assignment that satisfies the CNF.\n\nFields\n\nvariables::Vector{T}: The variables in the CNF.\ncnf::CNF{T}: The CNF expression.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.LogicGadget","page":"Reference","title":"ProblemReductions.LogicGadget","text":"struct LogicGadget{PT<:AbstractProblem}\n\nThe logic gadget defined on an computational model.\n\nFields\n\nproblem::PT: the computational model, e.g., SpinGlass.\ninputs::Vector{Int}: the input variables.\noutputs::Vector{Int}: the output variables.\n\nReferences\n\nWhat are the cost function for NAND and NOR gates?\nNguyen, M.-T., Liu, J.-G., Wurtz, J., Lukin, M.D., Wang, S.-T., Pichler, H., 2023. Quantum Optimization with Arbitrary Connectivity Using Rydberg Atom Arrays. PRX Quantum 4, 010316.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.Matching","page":"Reference","title":"ProblemReductions.Matching","text":"struct Matching{WT<:Union{UnitWeight, Vector}} <: AbstractProblem\n\nThe Vertex matching problem.\n\nPositional arguments\n\ngraph is the problem graph.\nweights are associated with the edges of the graph.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.MaxCut","page":"Reference","title":"ProblemReductions.MaxCut","text":"struct MaxCut{WT<:(AbstractVector)} <: AbstractProblem\n\nThe cutting problem.\n\nIn this problem, we would like to find the cut of the graph that maximizes the sum of the \n\nweights of the edges that are cut.\n\nPositional arguments\n\ngraph is the problem graph.\nweights are associated with the edges of the graph. We have ensure that the weights are in the same order as the edges in edges(graph).\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.MaximalIS","page":"Reference","title":"ProblemReductions.MaximalIS","text":"struct MaximalIS{WT<:Union{UnitWeight, Vector}} <: AbstractProblem\n\nThe [maximal independent set]problem.  In the constructor, weights are the weights of vertices.\n\nPositional arguments\n\ngraph is the problem graph.\nweights are associated with the vertices of the graph.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.QUBO","page":"Reference","title":"ProblemReductions.QUBO","text":"struct QUBO{T<:Real} <: AbstractProblem\n\nThe quadratic unconstrained binary optimization.\n\nE = sum_ij Q_ij x_i x_j\n\nwhere x_i \\in \\{0, 1\\}.\n\nArguments\n\nmatrix::AbstractMatrix: the matrix Q of the QUBO problem.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.ReductionCircuitToSpinGlass","page":"Reference","title":"ProblemReductions.ReductionCircuitToSpinGlass","text":"struct ReductionCircuitToSpinGlass{GT, T}\n\nThe reduction result of a circuit to a spin glass problem.\n\nFields\n\nnum_source_vars::Int: the number of variables in the source circuit.\nspinglass::SpinGlass{GT, T}: the spin glass problem.\nvariables::Vector{Int}: the variables in the spin glass problem.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.ReductionFactoringToSat","page":"Reference","title":"ProblemReductions.ReductionFactoringToSat","text":"struct ReductionFactoringToSat <: AbstractReductionResult\n\nThe reduction result of a  factoring problem to a CircuitSAT problem.\n\nFields\n\ncircuit::CircuitSAT: the CircuitSAT problem.\np::Vector{Int}: the first number to multiply (store bit locations)\nq::Vector{Int}: the second number to multiply.\nm::Vector{Int}: the result of the multiplication.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.ReductionMaxCutToSpinGlass","page":"Reference","title":"ProblemReductions.ReductionMaxCutToSpinGlass","text":"struct ReductionMaxCutToSpinGlass{GT, T}\n\nThe reduction result of a maxcut to a spin glass problem.\n\nFields\n\nspinglass::SpinGlass{GT, T}: the spin glass problem.\n\nWe only consider a simple reduction from MaxCut to SpinGlass(the graph must be SimpleGraph).\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.ReductionQUBOToSpinGlass","page":"Reference","title":"ProblemReductions.ReductionQUBOToSpinGlass","text":"struct ReductionQUBOToSpinGlass{GT, T}\n\nThe reduction result of a qubo to a spin glass problem.\n\nFields\n\nspinglass::SpinGlass{GT, T}: the spin glass problem.\n\nWe only consider a simple reduction from QUBO to SpinGlass(the graph must be SimpleGraph).\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.ReductionSATTo3SAT","page":"Reference","title":"ProblemReductions.ReductionSATTo3SAT","text":"The reduction result of a general SAT problem to a 3-SAT problem.\n\nFields\n\nsat_source::Satisfiability{GT, T}: the source general SAT problem.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.ReductionSATToIndependentSet","page":"Reference","title":"ProblemReductions.ReductionSATToIndependentSet","text":"struct ReductionSATToIndependentSet{T, GT<:Graphs.AbstractGraph, WT<:(AbstractVector)}\n\nThe reduction result of a general SAT problem to an Independent Set problem.\n\nFields\n\ntarget::IndependentSet\nliterals::Array{BoolVar{T}, 1} where T\nsource_variables::Vector\nnum_clauses::Int64\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.ReductionSatToColoring","page":"Reference","title":"ProblemReductions.ReductionSatToColoring","text":"struct ReductionSatToColoring{K, T, WT<:(AbstractVector)}\n\nThe reduction result of a Sat problem to a Coloring problem.\n\nFields\n\nColoring{K, WT<:AbstractVector}: the coloring problem, where K is the number of colors and WT is the weights type. \nvarlabel, used to filter extra variables\n\nNote: The coloring problem is a 3 coloring problem, in which a auxiliary color is used Auxiliary color => 2.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.ReductionSpinGlassToMaxCut","page":"Reference","title":"ProblemReductions.ReductionSpinGlassToMaxCut","text":"struct ReductionSpinGlassToMaxCut{WT}\n\nThe reduction result of a spin glass to a maxcut problem.\n\nFields\n\nmaxcut::MaxCut{WT}: the MaxCut problem.\nancilla::Int: the ancilla vertex.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.ReductionSpinGlassToQUBO","page":"Reference","title":"ProblemReductions.ReductionSpinGlassToQUBO","text":"struct ReductionSpinGlassToQUBO{WT}\n\nThe reduction result of a spin glass to a QUBO problem.\n\nFields\n\nqubo::QUBO{WT}: the QUBO problem.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.ReductionVertexCoveringToSetCovering","page":"Reference","title":"ProblemReductions.ReductionVertexCoveringToSetCovering","text":"struct ReductionVertexCoveringToSetCovering{ET, WT<:(AbstractVector)}\n\nThe reduction result of a vertex covering to a set covering problem.\n\nFields\n\nsetcovering::SetCovering{ET,WT}: the set covering problem, where ET is the sets type and WT is the weights type.\nedgelabel: map each edge to a number in order to identify the edge (otherwise the vector would be cluttering)\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.Satisfiability","page":"Reference","title":"ProblemReductions.Satisfiability","text":"struct Satisfiability{T} <: ProblemReductions.AbstractSatisfiabilityProblem{T}\n\nThe satisfiability problem.\n\nFields\n\ncnf is a conjunctive normal form (CNF) for specifying the satisfiability problems.\nweights are associated with clauses.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.SetPacking","page":"Reference","title":"ProblemReductions.SetPacking","text":"struct SetPacking{ET} <: AbstractProblem\n\nThe set packing problem, a generalization of independent set problem to hypergraphs.\n\nPositional arguments\n\nelements is a vector of elements in the universe.\nsets is a vector of vectors, each set is associated with a weight specified in weights.\n\nCurrently this type problem doesn't support weights.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.SpinGlass","page":"Reference","title":"ProblemReductions.SpinGlass","text":"struct SpinGlass{GT<:Graphs.AbstractGraph, WT<:(AbstractVector)} <: AbstractProblem\n\nSpinGlass(graph::AbstractGraph, J, h=zeros(nv(graph)))\n\nThe spin-glass problem.\n\nPositional arguments\n\ngraph is a graph object.\nweights are associated with the edges.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.StaticBitVector","page":"Reference","title":"ProblemReductions.StaticBitVector","text":"StaticBitVector{N,C} = StaticElementVector{N,1,C}\nStaticBitVector(x::AbstractVector)\n\nExamples\n\njulia> sb = StaticBitVector([1,0,0,1,1])\n10011\n\njulia> sb[3]\n0x0000000000000000\n\njulia> collect(Int, sb)\n5-element Vector{Int64}:\n 1\n 0\n 0\n 1\n 1\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.StaticElementVector","page":"Reference","title":"ProblemReductions.StaticElementVector","text":"StaticElementVector{N,S,C}\nStaticElementVector(nflavor::Int, x::AbstractVector)\n\nN is the length of vector, C is the size of storage in unit of UInt64, S is the stride defined as the log2(# of flavors). When the number of flavors is 2, it is a StaticBitVector.\n\nFields\n\ndata is a tuple of UInt64 for storing the configuration of static elements.\n\nExamples\n\njulia> ev = StaticElementVector(3, [1,2,0,1,2])\n12012\n\njulia> ev[2]\n0x0000000000000002\n\njulia> collect(Int, ev)\n5-element Vector{Int64}:\n 1\n 2\n 0\n 1\n 2\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.TruthTable","page":"Reference","title":"ProblemReductions.TruthTable","text":"struct TruthTable{N, T}\n\nThe truth table.\n\nFields\n\ninputs::Vector{T}: The input values.\noutputs::Vector{T}: The output values.\nvalues::Vector{BitStr{N, Int}}: The truth table values.\n\nExamples\n\njulia> tt = TruthTable(['a', 'b'], ['c'], [bit\"0\", bit\"0\", bit\"0\", bit\"1\"])\n┌───┬───┬───┐\n│ a │ b │ c │\n├───┼───┼───┤\n│ 0 │ 0 │ 0 │\n│ 1 │ 0 │ 0 │\n│ 0 │ 1 │ 0 │\n│ 1 │ 1 │ 1 │\n└───┴───┴───┘\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.UnitDiskGraph","page":"Reference","title":"ProblemReductions.UnitDiskGraph","text":"struct UnitDiskGraph{D, T} <: Graphs.AbstractGraph{Int64}\n\nA unit disk graph is a graph in which the vertices are points in a plane and two vertices are connected by an edge if and only if the Euclidean distance between them is at most a given radius.\n\nFields\n\nn::Int: the number of vertices\nlocations::Vector{NTuple{D, T}}: the locations of the vertices\nradius::T: the radius of the unit disk\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.VertexCovering","page":"Reference","title":"ProblemReductions.VertexCovering","text":"struct VertexCovering{WT<:(AbstractVector)} <: AbstractProblem\n\nVertex covering is a problem that seeks to find a minimum set of vertices that cover all edges in a graph.\n\nPositional arguments\n\ngraph is a graph object.\nweights are associated with the vertices of the graph, default to UnitWeight(nv(graph)).\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.:¬-Union{Tuple{BoolVar{T}}, Tuple{T}} where T","page":"Reference","title":"ProblemReductions.:¬","text":"¬(var::BoolVar)\n\nNegation of a boolean variables of type BoolVar.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.:∧-Union{Tuple{T}, Tuple{CNFClause{T}, Vararg{CNFClause{T}}}} where T","page":"Reference","title":"ProblemReductions.:∧","text":"∧(vars...)\n\nLogical and applied on CNFClause and CNF. Returns a new CNF.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.:∨-Union{Tuple{T}, Tuple{BoolVar{T}, Vararg{BoolVar{T}}}} where T","page":"Reference","title":"ProblemReductions.:∨","text":"∨(vars...)\n\nLogical or applied on BoolVar and CNFClause. Returns a CNFClause.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.configuration_space_size-Tuple{AbstractProblem}","page":"Reference","title":"ProblemReductions.configuration_space_size","text":"configuration_space_size(problem::AbstractProblem) -> Any\n\n\nReturn the log2 size of the configuration space of the problem.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.evaluate","page":"Reference","title":"ProblemReductions.evaluate","text":"evaluate(problem::AbstractProblem, config) -> Real\n\nEvaluate the energy of the problem given the configuration config. The lower the energy, the better the configuration.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.evaluate-Tuple{Coloring, Any}","page":"Reference","title":"ProblemReductions.evaluate","text":"evaluate(c::Coloring, config)\n\nCompute the energy of the vertex coloring configuration config, the energy is the number of violated edges.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.evaluate-Tuple{Matching, Any}","page":"Reference","title":"ProblemReductions.evaluate","text":"evaluate(c::Matching, config)\nReturn Inf if the configuration is not a matching, otherwise return the sum of the weights of the edges in the matching.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.evaluate-Tuple{MaxCut, Any}","page":"Reference","title":"ProblemReductions.evaluate","text":"evaluate(c::MaxCut, config)\n\nCompute the cut weights for the vertex configuration config (an iterator). The energy is the  sum of the weights of the edges that are cut.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.evaluate-Tuple{MaximalIS, Any}","page":"Reference","title":"ProblemReductions.evaluate","text":"evaluate(c::MaximalIS, config)\nReturn the weights of the vertices that are not in the maximal independent set.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.evaluate-Tuple{SetPacking, Any}","page":"Reference","title":"ProblemReductions.evaluate","text":"evaluate(c::SetPacking, config)\n\nFirst step: We check if config (a vector of boolean numbers as the mask of sets) is a set packing of sets;\nSecond step: If it is a set packing, we return - (size(set packing)); Otherwise, we return size(variables) + 1.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.evaluate-Tuple{VertexCovering, Any}","page":"Reference","title":"ProblemReductions.evaluate","text":"evaluate(c::VertexCovering, config)\n\nreturn the weights of edge that is not covered but return typemax(eltype(weights)) if the edge is not covered. config is a vector of boolean numbers.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.extract_multiple_solutions","page":"Reference","title":"ProblemReductions.extract_multiple_solutions","text":"extract_multiple_solutions(reduction::AbstractReductionResult, solution_set)\n\nExtract multiple solutions together solution_set of the target problem to the original problem.\n\nArguments\n\nreduction: The reduction result.\nsolution_set: The set of multiple solutions of the target problem.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.extract_solution","page":"Reference","title":"ProblemReductions.extract_solution","text":"extract_solution(reduction::AbstractReductionResult, solution)\n\nExtract the solution solution of the target problem to the original problem.\n\nArguments\n\nreduction: The reduction result.\nsolution: The solution of the target problem.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.findbest","page":"Reference","title":"ProblemReductions.findbest","text":"findbest(problem::AbstractProblem, method) -> Vector\n\nFind the best configurations of the problem using the method.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.flavor_to_logical-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Reference","title":"ProblemReductions.flavor_to_logical","text":"flavor_to_logical(::Type{T}, flavor) -> T\n\nConvert the flavor to a logical value.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.flavors-Tuple{GT} where GT<:AbstractProblem","page":"Reference","title":"ProblemReductions.flavors","text":"flavors(::Type{<:AbstractProblem}) -> Vector\n\nReturns a vector of integers as the flavors (domain) of a degree of freedom.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.is_matching-Tuple{SimpleGraph, Any}","page":"Reference","title":"ProblemReductions.is_matching","text":"is_matching(graph::SimpleGraph, config)\n\nReturns true if config is a valid matching on graph, and false if a vertex is double matched. config is a vector of boolean variables, which has one to one correspondence with edges(graph).\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.is_maximal_independent_set-Tuple{SimpleGraph, Any}","page":"Reference","title":"ProblemReductions.is_maximal_independent_set","text":"is_maximal_independent_set(g::SimpleGraph, config)\n\nReturn true if config (a vector of boolean numbers as the mask of vertices) is a maximal independent set of graph g.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.is_set_covering-Tuple{SetCovering, Any}","page":"Reference","title":"ProblemReductions.is_set_covering","text":"is_set_covering(c::SetCovering, config)\n\nReturn true if config (a vector of boolean numbers as the mask of sets) is a set covering of sets.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.is_set_packing-Union{Tuple{ST}, Tuple{AbstractVector{ST}, Any}} where ST","page":"Reference","title":"ProblemReductions.is_set_packing","text":"is_set_packing(sets::AbstractVector, config)\n\nReturn true if config (a vector of boolean numbers as the mask of sets) is a set packing of sets.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.is_vertex_coloring-Tuple{SimpleGraph, Any}","page":"Reference","title":"ProblemReductions.is_vertex_coloring","text":"is_vertex_coloring(graph::SimpleGraph, config)\n\nReturns true if the coloring specified by config is a valid one, i.e. does not violate the contraints of vertices of an edges having different colors.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.is_vertex_covering-Tuple{SimpleGraph, Any}","page":"Reference","title":"ProblemReductions.is_vertex_covering","text":"is_vertex_covering(graph::SimpleGraph, config)\n\nreturn true if the vertex configuration config is a vertex covering of the graph. Our judgement is based on the fact that for each edge, at least one of its vertices is selected.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.num_flavors-Tuple{GT} where GT<:AbstractProblem","page":"Reference","title":"ProblemReductions.num_flavors","text":"num_flavors(::Type{<:AbstractProblem}) -> Int\n\nReturns the number of flavors (domain) of a degree of freedom.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.num_variables-Tuple{AbstractProblem}","page":"Reference","title":"ProblemReductions.num_variables","text":"num_variables(problem::AbstractProblem) -> Int\n\nThe number of variables in the computational problem.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.onehotv-Union{Tuple{C}, Tuple{S}, Tuple{N}, Tuple{Type{StaticElementVector{N, S, C}}, Any, Any}} where {N, S, C}","page":"Reference","title":"ProblemReductions.onehotv","text":"onehotv(::Type{<:StaticElementVector}, i, v)\nonehotv(::Type{<:StaticBitVector, i)\n\nReturns a static element vector, with the value at location i being v (1 if not specified).\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.parameter_type-Tuple{AbstractProblem}","page":"Reference","title":"ProblemReductions.parameter_type","text":"parameter_type(problem::AbstractProblem) -> Type\n\nThe data type of the parameters in the computational problem.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.parameters","page":"Reference","title":"ProblemReductions.parameters","text":"parameters(problem::AbstractProblem) -> Vector\n\nThe parameters of the computational problem.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.problem_size","page":"Reference","title":"ProblemReductions.problem_size","text":"problem_size(problem::AbstractProblem) -> Int\n\nThe size of the computational problem. The measure of which depends on the problem.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.problem_size-Tuple{ProblemReductions.AbstractSatisfiabilityProblem}","page":"Reference","title":"ProblemReductions.problem_size","text":"problem size of the satisfiability problem is the number of clauses in the CNF.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.problem_size-Tuple{SetCovering}","page":"Reference","title":"ProblemReductions.problem_size","text":"Defined as the number of sets.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.problem_size-Tuple{SetPacking}","page":"Reference","title":"ProblemReductions.problem_size","text":"Defined as the number of elements times the number of sets.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.reduceto","page":"Reference","title":"ProblemReductions.reduceto","text":"reduceto(::Type{TA}, x::AbstractProblem)\n\nReduce the problem x to a target problem of type TA. Returns an instance of AbstractReductionResult.\n\nArguments\n\nTA: The target problem type.\nx: The original problem.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.reduction_complexity-Union{Tuple{TA}, Tuple{Type{TA}, AbstractProblem}} where TA<:AbstractProblem","page":"Reference","title":"ProblemReductions.reduction_complexity","text":"reduction_complexity(::Type{TA}, x::AbstractProblem) -> Int\n\nThe complexity of the reduction from the original problem to the target problem. Returns the polynomial order of the reduction.\n\nnote: Note\nThe problem size measure is problem dependent. Please check problem_size for the problem size measure.\n\nArguments\n\nTA: The target problem type.\nx: The original problem.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.satisfiable-Union{Tuple{T}, Tuple{CNF{T}, AbstractDict{T}}} where T","page":"Reference","title":"ProblemReductions.satisfiable","text":"satisfiable(cnf::CNF, config::AbstractDict)\n\nReturns true if an assignment of variables satisfies a CNF.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.set_parameters","page":"Reference","title":"ProblemReductions.set_parameters","text":"set_parameters(problem::AbstractProblem, parameters) -> AbstractProblem\n\nChange the parameters for the problem and return a new problem instance.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.spinglass_energy-Tuple{AbstractVector{Vector{Int64}}, Any}","page":"Reference","title":"ProblemReductions.spinglass_energy","text":"spinglass_energy(g::SimpleGraph, config; J, h)\nspinglass_energy(cliques::AbstractVector{Vector{Int}}, config; weights)\n\nCompute the spin glass state energy for the vertex configuration config. In the configuration, the spin ↑ is mapped to configuration 0, while spin ↓ is mapped to configuration 1. Let G=(VE) be the input graph, the hamiltonian is\n\nH = sum_ij in E J_ij s_i s_j + sum_i in V h_i s_i\n\nwhere s_i in -1 1 stands for spin ↓ and spin ↑.\n\nIn the hypergraph case, the hamiltonian is\n\nH = sum_c in C w_c prod_i in c s_i\n\nwhere C is the set of cliques, and w_c is the weight of the clique c.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.spinglass_gadget-Tuple{Val{:arraymul}}","page":"Reference","title":"ProblemReductions.spinglass_gadget","text":"spinglass_gadget(::Val{:arraymul})\n\nThe array multiplier gadget.\n\n    s_{i+1,j-1}  p_i\n           \\     |\n        q_j ------------ q_j\n                 |\n    c_{i,j} ------------ c_{i-1,j}\n                 |     \\\n                 p_i     s_{i,j} \n\nvariables: pi, qj, pq, c{i-1,j}, s{i+1,j-1}, c{i,j}, s{i,j}\nconstraints: 2 * c{i,j} + s{i,j} = pi qj + c{i-1,j} + s{i+1,j-1}\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.target_problem","page":"Reference","title":"ProblemReductions.target_problem","text":"target_problem(res::AbstractReductionResult) -> AbstractProblem\n\nReturn the target problem of the reduction result.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.truth_table-Tuple{LogicGadget}","page":"Reference","title":"ProblemReductions.truth_table","text":"truth_table(ga::LogicGadget; variables=1:num_variables(ga.problem), solver=BruteForce())\n\nCompute the truth table of a logic gadget.\n\nArguments\n\nga::LogicGadget: the logic gadget.\n\nKeyword Arguments\n\nvariables::Vector{Int}: the variables to be displayed.\nsolver::AbstractSolver: the solver to be used.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.variables","page":"Reference","title":"ProblemReductions.variables","text":"variables(problem::AbstractProblem) -> Vector\n\nThe degrees of freedoms in the computational problem. e.g. for the maximum independent set problems, they are the indices of vertices: 1, 2, 3..., while for the max cut problem, they are the edges.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.@bools-Tuple{Vararg{Symbol}}","page":"Reference","title":"ProblemReductions.@bools","text":"@bools(syms::Symbol...)\n\nCreate some boolean variables of type BoolVar in current scope that can be used in create a CNF.\n\nExample\n\nUnder Development\n\n\n\n\n\n","category":"macro"},{"location":"ref/#ProblemReductions.@bv_str-Tuple{Any}","page":"Reference","title":"ProblemReductions.@bv_str","text":"Constructing a static bit vector.\n\n\n\n\n\n","category":"macro"},{"location":"ref/#ProblemReductions.@circuit-Tuple{Any}","page":"Reference","title":"ProblemReductions.@circuit","text":"@circuit circuit_expr\n\nConstruct a circuit expression from a block of assignments.\n\nExamples\n\njulia> @circuit begin\n        x = a ∨ b\n        y = x ∧ c\n       end\nCircuit:\n| x = ∨(a, b)\n| y = ∧(x, c)\n\n\n\n\n\n","category":"macro"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = ProblemReductions","category":"page"},{"location":"#ProblemReductions","page":"Home","title":"ProblemReductions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for ProblemReductions. This package is expected to be a tool for researchers to study the relationship between different computational hard problems. It defines a set of computational hard problems and provides a set of functions to reduce one problem to another. The package is designed to be extensible, so that users can easily add new reductions to the package.","category":"page"},{"location":"rules/#Problem-Reduction-Rules","page":"Problem Reduction Rules","title":"Problem Reduction Rules","text":"","category":"section"},{"location":"rules/","page":"Problem Reduction Rules","title":"Problem Reduction Rules","text":"A problem reduction rule is a function that reduces a problem to another problem. By solving the target problem, we can extract the solution to the original problem. The reduction rule is defined as a function that takes an instance of the original problem and returns an AbstractReductionResult instance of the target problem.","category":"page"},{"location":"rules/#Interfaces","page":"Problem Reduction Rules","title":"Interfaces","text":"","category":"section"},{"location":"rules/","page":"Problem Reduction Rules","title":"Problem Reduction Rules","text":"reduceto: Reduce the source problem to a target problem of a specific type. Returns an AbstractReductionResult instance, which contains the target problem.\ntarget_problem: Return the target problem of the reduction result.\nextract_solution: Extract the solution of the target problem to the original problem.","category":"page"},{"location":"rules/","page":"Problem Reduction Rules","title":"Problem Reduction Rules","text":"Optional functions include:","category":"page"},{"location":"rules/","page":"Problem Reduction Rules","title":"Problem Reduction Rules","text":"reduction_complexity: The computational complexity of the reduction rule.","category":"page"},{"location":"models/CircuitSAT/#Circuit-Satisfaction","page":"Circuit Satisfaction","title":"Circuit Satisfaction","text":"","category":"section"},{"location":"models/CircuitSAT/#Problem-Definition","page":"Circuit Satisfaction","title":"Problem Definition","text":"","category":"section"},{"location":"models/CircuitSAT/","page":"Circuit Satisfaction","title":"Circuit Satisfaction","text":"A circuit can be defined with the @circuit macro as follows:","category":"page"},{"location":"models/CircuitSAT/","page":"Circuit Satisfaction","title":"Circuit Satisfaction","text":"using ProblemReductions\n\ncircuit = @circuit begin\n    c = x ∧ y\n    d = x ∨ (c ∧ ¬z)\nend","category":"page"},{"location":"models/CircuitSAT/","page":"Circuit Satisfaction","title":"Circuit Satisfaction","text":"The circuit can be converted to a CircuitSAT problem instance:","category":"page"},{"location":"models/CircuitSAT/","page":"Circuit Satisfaction","title":"Circuit Satisfaction","text":"sat = CircuitSAT(circuit)\nsat.symbols","category":"page"},{"location":"models/CircuitSAT/","page":"Circuit Satisfaction","title":"Circuit Satisfaction","text":"Note that the circuit is converted to the static single assignment (SSA) form, and the symbols are stored in the symbols field. The symbols are variables in the circuit to be assigned to true or false.","category":"page"},{"location":"models/CircuitSAT/#Interfaces","page":"Circuit Satisfaction","title":"Interfaces","text":"","category":"section"},{"location":"models/CircuitSAT/","page":"Circuit Satisfaction","title":"Circuit Satisfaction","text":"variables(sat)\nflavors(sat)","category":"page"},{"location":"models/CircuitSAT/","page":"Circuit Satisfaction","title":"Circuit Satisfaction","text":"The circuit can be evaluated with the evaluate function:","category":"page"},{"location":"models/CircuitSAT/","page":"Circuit Satisfaction","title":"Circuit Satisfaction","text":"evaluate(sat, [true, false, true, true, false, false, true])","category":"page"},{"location":"models/CircuitSAT/","page":"Circuit Satisfaction","title":"Circuit Satisfaction","text":"The return value is 0 if the assignment satisfies the circuit, otherwise, it is the number of unsatisfied clauses.","category":"page"},{"location":"models/CircuitSAT/","page":"Circuit Satisfaction","title":"Circuit Satisfaction","text":"note: Note\nevaluate funciton returns lower values for satisfiable assignments.","category":"page"},{"location":"models/CircuitSAT/","page":"Circuit Satisfaction","title":"Circuit Satisfaction","text":"To find all satisfying assignments, use the findbest function:","category":"page"},{"location":"models/CircuitSAT/","page":"Circuit Satisfaction","title":"Circuit Satisfaction","text":"findbest(sat, BruteForce())","category":"page"},{"location":"models/CircuitSAT/","page":"Circuit Satisfaction","title":"Circuit Satisfaction","text":"Here, the BruteForce solver is used to find the best assignment.","category":"page"}]
}
