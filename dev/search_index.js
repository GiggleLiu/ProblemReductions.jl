var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = ProblemReductions","category":"page"},{"location":"#ProblemReductions","page":"Home","title":"ProblemReductions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for ProblemReductions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [ProblemReductions]","category":"page"},{"location":"#ProblemReductions.AbstractProblem","page":"Home","title":"ProblemReductions.AbstractProblem","text":"AbstractProblem\n\nThe abstract base type of graph problems.\n\n\n\n\n\n","category":"type"},{"location":"#ProblemReductions.CircuitSAT","page":"Home","title":"ProblemReductions.CircuitSAT","text":"struct CircuitSAT <: ProblemReductions.AbstractProblem\n\nCircuit satisfiability problem.\n\nFields\n\ncircuit::Circuit: The circuit expression in SSA form.\nsymbols::Vector{Symbol}: The variables in the circuit.\n\n\n\n\n\n","category":"type"},{"location":"#ProblemReductions.GridGraph","page":"Home","title":"ProblemReductions.GridGraph","text":"struct GridGraph <: Graphs.AbstractGraph{Int64}\n\nA grid graph is a graph in which the vertices are arranged in a grid and two vertices are connected by an edge if and only if they are adjacent in the grid.\n\nFields\n\ngrid::BitMatrix: a matrix of booleans, where true indicates the presence of an edge.\nradius::Float64: the radius of the unit disk\n\n\n\n\n\n","category":"type"},{"location":"#ProblemReductions.HyperGraph","page":"Home","title":"ProblemReductions.HyperGraph","text":"struct HyperGraph <: Graphs.AbstractGraph{Int64}\n\nA hypergraph is a generalization of a graph in which an edge can connect any number of vertices.\n\nFields\n\nn::Int: the number of vertices\nedges::Vector{Vector{Int}}: a vector of vectors of integers, where each vector represents a hyperedge connecting the vertices with the corresponding indices.\n\n\n\n\n\n","category":"type"},{"location":"#ProblemReductions.ReductionCircuitToSpinGlass","page":"Home","title":"ProblemReductions.ReductionCircuitToSpinGlass","text":"struct ReductionCircuitToSpinGlass{GT, T}\n\nThe reduction result of a circuit to a spin glass problem.\n\nFields\n\nspinglass::SpinGlass{GT, T}: the spin glass problem.\nvariables::Vector{Int}: the variables in the spin glass problem.\n\n\n\n\n\n","category":"type"},{"location":"#ProblemReductions.SpinGlass","page":"Home","title":"ProblemReductions.SpinGlass","text":"struct SpinGlass{GT<:Graphs.AbstractGraph, T} <: ProblemReductions.AbstractProblem\n\nSpinGlass(graph::AbstractGraph, J, h=zeros(nv(graph)))\n\nThe spin-glass problem.\n\nPositional arguments\n\ngraph is a graph object.\nweights are associated with the edges.\n\n\n\n\n\n","category":"type"},{"location":"#ProblemReductions.StaticBitVector","page":"Home","title":"ProblemReductions.StaticBitVector","text":"StaticBitVector{N,C} = StaticElementVector{N,1,C}\nStaticBitVector(x::AbstractVector)\n\nExamples\n\njulia> sb = StaticBitVector([1,0,0,1,1])\n10011\n\njulia> sb[3]\n0x0000000000000000\n\njulia> collect(Int, sb)\n5-element Vector{Int64}:\n 1\n 0\n 0\n 1\n 1\n\n\n\n\n\n","category":"type"},{"location":"#ProblemReductions.StaticElementVector","page":"Home","title":"ProblemReductions.StaticElementVector","text":"StaticElementVector{N,S,C}\nStaticElementVector(nflavor::Int, x::AbstractVector)\n\nN is the length of vector, C is the size of storage in unit of UInt64, S is the stride defined as the log2(# of flavors). When the number of flavors is 2, it is a StaticBitVector.\n\nFields\n\ndata is a tuple of UInt64 for storing the configuration of static elements.\n\nExamples\n\njulia> ev = StaticElementVector(3, [1,2,0,1,2])\n12012\n\njulia> ev[2]\n0x0000000000000002\n\njulia> collect(Int, ev)\n5-element Vector{Int64}:\n 1\n 2\n 0\n 1\n 2\n\n\n\n\n\n","category":"type"},{"location":"#ProblemReductions.TruthTable","page":"Home","title":"ProblemReductions.TruthTable","text":"struct TruthTable{N, T}\n\nThe truth table.\n\nFields\n\ninputs::Vector{T}: The input values.\noutputs::Vector{T}: The output values.\nvalues::Vector{BitStr{N, Int}}: The truth table values.\n\nExamples\n\njulia> tt = TruthTable(['a', 'b'], ['c'], [bit\"0\", bit\"0\", bit\"0\", bit\"1\"])\n┌───┬───┬───┐\n│ a │ b │ c │\n├───┼───┼───┤\n│ 0 │ 0 │ 0 │\n│ 1 │ 0 │ 0 │\n│ 0 │ 1 │ 0 │\n│ 1 │ 1 │ 1 │\n└───┴───┴───┘\n\n\n\n\n\n","category":"type"},{"location":"#ProblemReductions.UnitDiskGraph","page":"Home","title":"ProblemReductions.UnitDiskGraph","text":"struct UnitDiskGraph{D, T} <: Graphs.AbstractGraph{Int64}\n\nA unit disk graph is a graph in which the vertices are points in a plane and two vertices are connected by an edge if and only if the Euclidean distance between them is at most a given radius.\n\nFields\n\nn::Int: the number of vertices\nlocations::Vector{NTuple{D, T}}: the locations of the vertices\nradius::T: the radius of the unit disk\n\n\n\n\n\n","category":"type"},{"location":"#ProblemReductions.chweights","page":"Home","title":"ProblemReductions.chweights","text":"chweights(problem::AbstractProblem, weights) -> AbstractProblem\n\nChange the weights for the problem and return a new problem instance. Weights are associated with terms in the graph problem. In graph polynomial, integer weights can be the exponents.\n\n\n\n\n\n","category":"function"},{"location":"#ProblemReductions.energy_type-Tuple{ProblemReductions.AbstractProblem}","page":"Home","title":"ProblemReductions.energy_type","text":"energy_type(problem::AbstractProblem) -> Type\n\nThe energy type of the graph problem.\n\n\n\n\n\n","category":"method"},{"location":"#ProblemReductions.extract_solution","page":"Home","title":"ProblemReductions.extract_solution","text":"extract_solution(::Type{TA}, y::AbstractProblem, sol)\n\nExtract the solution sol of the target problem of type TA to the original problem y.\n\nArguments\n\nTA: The target problem type.\ny: The original problem.\nsol: The solution of the target problem.\n\n\n\n\n\n","category":"function"},{"location":"#ProblemReductions.flavors-Tuple{GT} where GT<:ProblemReductions.AbstractProblem","page":"Home","title":"ProblemReductions.flavors","text":"flavors(::Type{<:AbstractProblem}) -> Vector\n\nIt returns a vector of integers as the flavors of a degree of freedom. Its size is the same as the degree of freedom on a single vertex/edge.\n\n\n\n\n\n","category":"method"},{"location":"#ProblemReductions.get_weights","page":"Home","title":"ProblemReductions.get_weights","text":"get_weights(problem::AbstractProblem[, i::Int]) -> Vector\n\nThe weights for the problem or the weights for the degree of freedom specified by the i-th term if a second argument is provided. Weights are associated with terms in the graph problem. In graph polynomial, integer weights can be the exponents.\n\n\n\n\n\n","category":"function"},{"location":"#ProblemReductions.local_energy","page":"Home","title":"ProblemReductions.local_energy","text":"local_energy(problem::AbstractProblem[, i::Int]) -> Vector\n\nThe local energy( of the i-th term) in the graph problem.\n\n\n\n\n\n","category":"function"},{"location":"#ProblemReductions.nflavor-Union{Tuple{Type{GT}}, Tuple{GT}} where GT","page":"Home","title":"ProblemReductions.nflavor","text":"nflavor(::Type{<:AbstractProblem}) -> Int\nnflavor(::GT) where GT<:AbstractProblem -> Int\n\nBond size is equal to the number of flavors.\n\n\n\n\n\n","category":"method"},{"location":"#ProblemReductions.num_terms-Tuple{ProblemReductions.AbstractProblem}","page":"Home","title":"ProblemReductions.num_terms","text":"num_terms(problem::AbstractProblem) -> Int\n\nThe number of terms in the graph problem.\n\n\n\n\n\n","category":"method"},{"location":"#ProblemReductions.num_variables-Tuple{ProblemReductions.AbstractProblem}","page":"Home","title":"ProblemReductions.num_variables","text":"num_variables(problem::AbstractProblem) -> Int\n\nThe number of variables in the graph problem.\n\n\n\n\n\n","category":"method"},{"location":"#ProblemReductions.onehotv-Union{Tuple{C}, Tuple{S}, Tuple{N}, Tuple{Type{StaticElementVector{N, S, C}}, Any, Any}} where {N, S, C}","page":"Home","title":"ProblemReductions.onehotv","text":"onehotv(::Type{<:StaticElementVector}, i, v)\nonehotv(::Type{<:StaticBitVector, i)\n\nReturns a static element vector, with the value at location i being v (1 if not specified).\n\n\n\n\n\n","category":"method"},{"location":"#ProblemReductions.reduceto","page":"Home","title":"ProblemReductions.reduceto","text":"reduceto(::Type{TA}, x::AbstractProblem)\n\nReduce the problem x to a target problem of type TA. Returns an instance of AbstractReductionResult.\n\nArguments\n\nTA: The target problem type.\nx: The original problem.\n\n\n\n\n\n","category":"function"},{"location":"#ProblemReductions.spinglass_energy-Tuple{AbstractVector{Vector{Int64}}, Any}","page":"Home","title":"ProblemReductions.spinglass_energy","text":"spinglass_energy(g::SimpleGraph, config; J, h=ZeroWeight())\nspinglass_energy(cliques::AbstractVector{Vector{Int}}, config; weights=UnitWeight())\n\nCompute the spin glass state energy for the vertex configuration config. In the configuration, the spin ↑ is mapped to configuration 0, while spin ↓ is mapped to configuration 1. Let G=(VE) be the input graph, the hamiltonian is\n\nH = sum_ij in E J_ij s_i s_j + sum_i in V h_i s_i\n\nwhere s_i in -1 1 stands for spin ↓ and spin ↑.\n\nIn the hypergraph case, the hamiltonian is\n\nH = sum_c in C w_c prod_i in c s_i\n\nwhere C is the set of cliques, and w_c is the weight of the clique c.\n\n\n\n\n\n","category":"method"},{"location":"#ProblemReductions.spinglass_gadget-Tuple{Val{:arraymul}}","page":"Home","title":"ProblemReductions.spinglass_gadget","text":"spinglass_gadget(::Val{:arraymul})\n\nThe array multiplier gadget.\n\n    s_{i+1,j-1}  p_i\n           \\     |\n        q_j ------------ q_j\n                 |\n    c_{i,j} ------------ c_{i-1,j}\n                 |     \\\n                 p_i     s_{i,j} \n\nvariables: pi, qj, pq, c{i-1,j}, s{i+1,j-1}, c{i,j}, s{i,j}\nconstraints: 2 * c{i,j} + s{i,j} = pi qj + c{i-1,j} + s{i+1,j-1}\n\n\n\n\n\n","category":"method"},{"location":"#ProblemReductions.target_problem","page":"Home","title":"ProblemReductions.target_problem","text":"target_problem(res::AbstractReductionResult) -> AbstractProblem\n\nReturn the target problem of the reduction result.\n\n\n\n\n\n","category":"function"},{"location":"#ProblemReductions.terms","page":"Home","title":"ProblemReductions.terms","text":"terms(problem::AbstractProblem) -> Vector\n\nThe energy terms of a graph problem is defined as the variables that carrying local energies (or weights) in the graph problem.\n\n\n\n\n\n","category":"function"},{"location":"#ProblemReductions.variables","page":"Home","title":"ProblemReductions.variables","text":"variables(problem::AbstractProblem) -> Vector\n\nThe variables of a problem is defined as the degrees of freedoms in the graph problem. e.g. for the maximum independent set problems, they are the indices of vertices: 1, 2, 3..., while for the max cut problem, they are the edges.\n\n\n\n\n\n","category":"function"},{"location":"#ProblemReductions.@bv_str-Tuple{Any}","page":"Home","title":"ProblemReductions.@bv_str","text":"Constructing a static bit vector.\n\n\n\n\n\n","category":"macro"},{"location":"#ProblemReductions.@circuit-Tuple{Any}","page":"Home","title":"ProblemReductions.@circuit","text":"@circuit circuit_expr\n\nConstruct a circuit expression from a block of assignments.\n\nExamples\n\njulia> @circuit begin\n        x = a ∨ b\n        y = x ∧ c\n       end\nCircuit:\n| x = ∨(a, b)\n| y = ∧(x, c)\n\n\n\n\n\n","category":"macro"}]
}
