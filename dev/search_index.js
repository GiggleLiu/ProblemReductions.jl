var documenterSearchIndex = {"docs":
[{"location":"topology/#Graph-Topology","page":"Graph Topology","title":"Graph Topology","text":"","category":"section"},{"location":"topology/","page":"Graph Topology","title":"Graph Topology","text":"SimpleGraph: A simple graph is an undirected graph with no self-loops or multiple edges between the same pair of vertices.\nHyperGraph: A hypergraph is a generalization of a graph in which an edge can connect any number of vertices.\nUnitDiskGraph: A unit disk graph is a graph in which vertices are placed in the Euclidean plane and edges are drawn between vertices that are within a fixed distance of each other.\nGridGraph: A grid graph is a graph in which vertices are placed on a grid and edges are drawn between vertices that are adjacent in the grid.","category":"page"},{"location":"topology/#Interfaces","page":"Graph Topology","title":"Interfaces","text":"","category":"section"},{"location":"topology/","page":"Graph Topology","title":"Graph Topology","text":"The minimum required functions for a graph are:","category":"page"},{"location":"topology/","page":"Graph Topology","title":"Graph Topology","text":"vertices: The vertices in the graph.\nedges: The edges in the graph.","category":"page"},{"location":"topology/","page":"Graph Topology","title":"Graph Topology","text":"Optional functions include:","category":"page"},{"location":"topology/","page":"Graph Topology","title":"Graph Topology","text":"ne: The number of edges in the graph.\nnv: The number of vertices in the graph.","category":"page"},{"location":"topology/","page":"Graph Topology","title":"Graph Topology","text":"These interfaces are defined in the Graphs package.","category":"page"},{"location":"models/SpinGlass/#Spin-Glass","page":"Spin Glass","title":"Spin Glass","text":"","category":"section"},{"location":"models/SpinGlass/#Problem-Definition","page":"Spin Glass","title":"Problem Definition","text":"","category":"section"},{"location":"models/SpinGlass/","page":"Spin Glass","title":"Spin Glass","text":"Spin Glass is a type of disordered magnetic system that exhibits a glassy behavior. The Hamiltonian of the system on a simple graph G is given by","category":"page"},{"location":"models/SpinGlass/","page":"Spin Glass","title":"Spin Glass","text":"H(G sigma) = sum_(ij) in E(G) J_ij sigma_i sigma_j","category":"page"},{"location":"models/SpinGlass/","page":"Spin Glass","title":"Spin Glass","text":"where J_ij is the coupling strength between spins i and j and sigma_i is the spin variable that can take values in -1 1.","category":"page"},{"location":"models/SpinGlass/","page":"Spin Glass","title":"Spin Glass","text":"This definition naturally extends to the case of a HyperGraph.","category":"page"},{"location":"models/SpinGlass/#Interfaces","page":"Spin Glass","title":"Interfaces","text":"","category":"section"},{"location":"models/SpinGlass/","page":"Spin Glass","title":"Spin Glass","text":"To define a SpinGlass problem, we need to specify the graph, the coupling strength J_ij, and possibly the external field h_i for each spin i.","category":"page"},{"location":"models/SpinGlass/","page":"Spin Glass","title":"Spin Glass","text":"using ProblemReductions, ProblemReductions.Graphs\n\ngraph = smallgraph(:petersen)\nJ = rand([1, -1], ne(graph))  # coupling strength\nh = rand([1, -1], nv(graph))  # external field\nspinglass = SpinGlass(graph, J, h)  # Define a spin glass problem","category":"page"},{"location":"models/SpinGlass/","page":"Spin Glass","title":"Spin Glass","text":"Here, we also define an external field h_i for each spin i. The resulting spin glass problem is defined on a HyperGraph, where external fields are associated with hyperedges connecting single spins.","category":"page"},{"location":"models/SpinGlass/","page":"Spin Glass","title":"Spin Glass","text":"The required functions, variables, flavors, and evaluate, and optional functions, findbest, are implemented for the spin glass problem.","category":"page"},{"location":"models/SpinGlass/","page":"Spin Glass","title":"Spin Glass","text":"variables(spinglass)  # degrees of freedom\nflavors(spinglass)  # flavors of the spins\nevaluate(spinglass, [0, 1, 1, 0, 1, 1, 1, 0, 0, 1])  # energy of a configuration\nfindbest(spinglass, BruteForce())  # solve the problem with brute force","category":"page"},{"location":"models/#Model-Problem","page":"Model Problem","title":"Model Problem","text":"","category":"section"},{"location":"models/","page":"Model Problem","title":"Model Problem","text":"A model problem is a subclass of AbstractProblem that defines the energy function of a computational problem. Facts affecting the computational complexity classification of the problem also include the topology of the problem and the domain of the variables.","category":"page"},{"location":"models/#Interfaces","page":"Model Problem","title":"Interfaces","text":"","category":"section"},{"location":"models/","page":"Model Problem","title":"Model Problem","text":"Required functions include:","category":"page"},{"location":"models/","page":"Model Problem","title":"Model Problem","text":"variables: The degrees of freedoms in the problem.   e.g. for the maximum independent set problems, they are the indices of vertices: 1, 2, 3...,   while for the max cut problem, they are the edges.\nflavors: A vector of integers as the flavors (or domain) of a degree of freedom.   e.g. for the maximum independent set problems, the flavors are [0, 1], where 0 means the vertex is not in the set and 1 means the vertex is in the set.\nterms: Variables that carrying local energies (or weights) in the problem.\nparameters: Energies associated with terms.\nevaluate: Evaluate the energy of a given configuration.","category":"page"},{"location":"models/","page":"Model Problem","title":"Model Problem","text":"Optional functions include:","category":"page"},{"location":"models/","page":"Model Problem","title":"Model Problem","text":"num_variables: The number of variables in the problem.\nnum_flavors: The number of flavors in the problem.\nset_parameters: Change the parameters for the problem and return a new problem instance.\nnum_terms: The number of terms in the computational problem.\nparameter_type: The data type of parameters.\nfindbest: Find the best configurations in the computational problem.","category":"page"},{"location":"rules/spinglass_sat/#CircuitSAT-SpinGlass","page":"CircuitSAT -> SpinGlass","title":"CircuitSAT -> SpinGlass","text":"","category":"section"},{"location":"rules/spinglass_sat/","page":"CircuitSAT -> SpinGlass","title":"CircuitSAT -> SpinGlass","text":"In this tutorial, we will demonstrate how to use the Spinglass model to solve the circuit satisfiability problem.","category":"page"},{"location":"rules/spinglass_sat/","page":"CircuitSAT -> SpinGlass","title":"CircuitSAT -> SpinGlass","text":"We first define a simple Circuit using the @circuit macro. And then we convert the circuit to a CircuitSAT problem.","category":"page"},{"location":"rules/spinglass_sat/","page":"CircuitSAT -> SpinGlass","title":"CircuitSAT -> SpinGlass","text":"using ProblemReductions\n\ncircuit = @circuit begin\n    c = x ∧ y\n    d = x ∨ (¬c ∧ ¬z)\nend\ncircuitsat = CircuitSAT(circuit)\nvariables(circuitsat)\ncircuitsat.symbols","category":"page"},{"location":"rules/spinglass_sat/","page":"CircuitSAT -> SpinGlass","title":"CircuitSAT -> SpinGlass","text":"The resulting circuitsat expands the expression to a list of simple clauses. The variables are mapped to integers that pointing to the symbols that stored in the symbols field.","category":"page"},{"location":"rules/spinglass_sat/","page":"CircuitSAT -> SpinGlass","title":"CircuitSAT -> SpinGlass","text":"The we can convert the circuit to a SpinGlass problem using the reduceto function.","category":"page"},{"location":"rules/spinglass_sat/","page":"CircuitSAT -> SpinGlass","title":"CircuitSAT -> SpinGlass","text":"result = reduceto(SpinGlass, circuitsat)","category":"page"},{"location":"rules/spinglass_sat/","page":"CircuitSAT -> SpinGlass","title":"CircuitSAT -> SpinGlass","text":"The resulting result is a ReductionCircuitToSpinGlass instance that contains the spin glass problem.","category":"page"},{"location":"rules/spinglass_sat/","page":"CircuitSAT -> SpinGlass","title":"CircuitSAT -> SpinGlass","text":"With the result instance, we can define a logic gadget that maps the spin glass variables to the circuit variables.","category":"page"},{"location":"rules/spinglass_sat/","page":"CircuitSAT -> SpinGlass","title":"CircuitSAT -> SpinGlass","text":"indexof(x) = findfirst(==(findfirst(==(x), circuitsat.symbols)), result.variables)\ngadget = LogicGadget(result.spinglass, indexof.([:x, :y, :z]), [indexof(:d)])\ntb = truth_table(gadget; variables=circuitsat.symbols[result.variables])","category":"page"},{"location":"rules/spinglass_sat/","page":"CircuitSAT -> SpinGlass","title":"CircuitSAT -> SpinGlass","text":"The gadget is a LogicGadget instance that maps the spin glass variables to the circuit variables. The truth_table function generates the truth table of the gadget.","category":"page"},{"location":"ref/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"ref/","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"ref/","page":"Reference","title":"Reference","text":"Modules = [ProblemReductions]","category":"page"},{"location":"ref/#ProblemReductions.AbstractProblem","page":"Reference","title":"ProblemReductions.AbstractProblem","text":"AbstractProblem\n\nThe abstract base type of computational problems.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.AbstractReductionResult","page":"Reference","title":"ProblemReductions.AbstractReductionResult","text":"abstract type AbstractReductionResult\n\nThe base type for a reduction result.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.BoolVar","page":"Reference","title":"ProblemReductions.BoolVar","text":"BoolVar{T}\nBoolVar(name, neg)\n\nBoolean variable for constructing CNF clauses.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.BruteForce","page":"Reference","title":"ProblemReductions.BruteForce","text":"BruteForce\n\nA brute force method to find the best configuration of a problem.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.CNF","page":"Reference","title":"ProblemReductions.CNF","text":"CNF{T}\nCNF(clauses)\n\nBoolean expression in conjunctive normal form. clauses is a vector of CNFClause, if and only if all clauses are satisfied, this CNF is satisfied.\n\nExample\n\nUnder development\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.CNFClause","page":"Reference","title":"ProblemReductions.CNFClause","text":"CNFClause{T}\nCNFClause(vars)\n\nA clause in CNF, its value is the logical or of vars, where vars is a vector of BoolVar.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.Circuit","page":"Reference","title":"ProblemReductions.Circuit","text":"struct Circuit\n\nA circuit expression is a sequence of assignments.\n\nFields\n\nexprs::Vector{Assignment}: The assignments in the circuit.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.CircuitSAT","page":"Reference","title":"ProblemReductions.CircuitSAT","text":"struct CircuitSAT <: AbstractProblem\n\nCircuit satisfiability problem, where the goal is to find an assignment that satisfies the circuit.\n\nFields\n\ncircuit::Circuit: The circuit expression in SSA form.\nsymbols::Vector{Symbol}: The variables in the circuit.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.Coloring","page":"Reference","title":"ProblemReductions.Coloring","text":"struct Coloring{K, WT<:Union{ProblemReductions.UnitWeight, Vector}} <: AbstractProblem\n\nColoring{K}(graph; weights=UnitWeight())\n\nThe Vertex Coloring problem.\n\nPositional arguments\n\ngraph is the problem graph.\nweights are associated with the edges of the graph, default to UnitWeight().\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.GridGraph","page":"Reference","title":"ProblemReductions.GridGraph","text":"struct GridGraph <: Graphs.AbstractGraph{Int64}\n\nA grid graph is a graph in which the vertices are arranged in a grid and two vertices are connected by an edge if and only if they are adjacent in the grid.\n\nFields\n\ngrid::BitMatrix: a matrix of booleans, where true indicates the presence of an edge.\nradius::Float64: the radius of the unit disk\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.HyperGraph","page":"Reference","title":"ProblemReductions.HyperGraph","text":"struct HyperGraph <: Graphs.AbstractGraph{Int64}\n\nA hypergraph is a generalization of a graph in which an edge can connect any number of vertices.\n\nFields\n\nn::Int: the number of vertices\nedges::Vector{Vector{Int}}: a vector of vectors of integers, where each vector represents a hyperedge connecting the vertices with the corresponding indices.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.LogicGadget","page":"Reference","title":"ProblemReductions.LogicGadget","text":"struct LogicGadget{PT<:AbstractProblem}\n\nThe logic gadget defined on an computational model.\n\nFields\n\nproblem::PT: the computational model, e.g., SpinGlass.\ninputs::Vector{Int}: the input variables.\noutputs::Vector{Int}: the output variables.\n\nReferences\n\nWhat are the cost function for NAND and NOR gates?\nNguyen, M.-T., Liu, J.-G., Wurtz, J., Lukin, M.D., Wang, S.-T., Pichler, H., 2023. Quantum Optimization with Arbitrary Connectivity Using Rydberg Atom Arrays. PRX Quantum 4, 010316.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.MaxCut","page":"Reference","title":"ProblemReductions.MaxCut","text":"struct MaxCut{WT1<:Union{ProblemReductions.UnitWeight, Vector}} <: AbstractProblem\n\nThe cutting problem.\n\nIn this problem, we would like to find the cut of the graph that maximizes the sum of the \n\nweights of the edges that are cut.\n\nPositional arguments\n\ngraph is the problem graph.\nedge_weights are associated with the edges of the graph.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.ReductionCircuitToSpinGlass","page":"Reference","title":"ProblemReductions.ReductionCircuitToSpinGlass","text":"struct ReductionCircuitToSpinGlass{GT, T}\n\nThe reduction result of a circuit to a spin glass problem.\n\nFields\n\nspinglass::SpinGlass{GT, T}: the spin glass problem.\nvariables::Vector{Int}: the variables in the spin glass problem.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.Satisfiability","page":"Reference","title":"ProblemReductions.Satisfiability","text":"The formal definition of SAT problem\n\nThe satisfiability problem.\n\nPositional arguments\n\ncnf is a conjunctive normal form (CNF) for specifying the satisfiability problems.\nweights are associated with clauses.\n\nExamples\n\nUnder Development\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.SpinGlass","page":"Reference","title":"ProblemReductions.SpinGlass","text":"struct SpinGlass{GT<:Graphs.AbstractGraph, T} <: AbstractProblem\n\nSpinGlass(graph::AbstractGraph, J, h=zeros(nv(graph)))\n\nThe spin-glass problem.\n\nPositional arguments\n\ngraph is a graph object.\nweights are associated with the edges.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.StaticBitVector","page":"Reference","title":"ProblemReductions.StaticBitVector","text":"StaticBitVector{N,C} = StaticElementVector{N,1,C}\nStaticBitVector(x::AbstractVector)\n\nExamples\n\njulia> sb = StaticBitVector([1,0,0,1,1])\n10011\n\njulia> sb[3]\n0x0000000000000000\n\njulia> collect(Int, sb)\n5-element Vector{Int64}:\n 1\n 0\n 0\n 1\n 1\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.StaticElementVector","page":"Reference","title":"ProblemReductions.StaticElementVector","text":"StaticElementVector{N,S,C}\nStaticElementVector(nflavor::Int, x::AbstractVector)\n\nN is the length of vector, C is the size of storage in unit of UInt64, S is the stride defined as the log2(# of flavors). When the number of flavors is 2, it is a StaticBitVector.\n\nFields\n\ndata is a tuple of UInt64 for storing the configuration of static elements.\n\nExamples\n\njulia> ev = StaticElementVector(3, [1,2,0,1,2])\n12012\n\njulia> ev[2]\n0x0000000000000002\n\njulia> collect(Int, ev)\n5-element Vector{Int64}:\n 1\n 2\n 0\n 1\n 2\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.TruthTable","page":"Reference","title":"ProblemReductions.TruthTable","text":"struct TruthTable{N, T}\n\nThe truth table.\n\nFields\n\ninputs::Vector{T}: The input values.\noutputs::Vector{T}: The output values.\nvalues::Vector{BitStr{N, Int}}: The truth table values.\n\nExamples\n\njulia> tt = TruthTable(['a', 'b'], ['c'], [bit\"0\", bit\"0\", bit\"0\", bit\"1\"])\n┌───┬───┬───┐\n│ a │ b │ c │\n├───┼───┼───┤\n│ 0 │ 0 │ 0 │\n│ 1 │ 0 │ 0 │\n│ 0 │ 1 │ 0 │\n│ 1 │ 1 │ 1 │\n└───┴───┴───┘\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.UnitDiskGraph","page":"Reference","title":"ProblemReductions.UnitDiskGraph","text":"struct UnitDiskGraph{D, T} <: Graphs.AbstractGraph{Int64}\n\nA unit disk graph is a graph in which the vertices are points in a plane and two vertices are connected by an edge if and only if the Euclidean distance between them is at most a given radius.\n\nFields\n\nn::Int: the number of vertices\nlocations::Vector{NTuple{D, T}}: the locations of the vertices\nradius::T: the radius of the unit disk\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.:¬-Union{Tuple{ProblemReductions.BoolVar{T}}, Tuple{T}} where T","page":"Reference","title":"ProblemReductions.:¬","text":"¬(var::BoolVar)\n\nNegation of a boolean variables of type BoolVar.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.:∧-Union{Tuple{T}, Tuple{ProblemReductions.CNFClause{T}, Vararg{ProblemReductions.CNFClause{T}}}} where T","page":"Reference","title":"ProblemReductions.:∧","text":"∧(vars...)\n\nLogical and applied on CNFClause and CNF. Returns a new CNF.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.:∨-Union{Tuple{T}, Tuple{ProblemReductions.BoolVar{T}, Vararg{ProblemReductions.BoolVar{T}}}} where T","page":"Reference","title":"ProblemReductions.:∨","text":"∨(vars...)\n\nLogical or applied on BoolVar and CNFClause. Returns a CNFClause.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.evaluate","page":"Reference","title":"ProblemReductions.evaluate","text":"evaluate(problem::AbstractProblem, config) -> Real\n\nEvaluate the energy of the problem given the configuration config. The lower the energy, the better the configuration.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.evaluate-Tuple{ProblemReductions.Coloring, Any}","page":"Reference","title":"ProblemReductions.evaluate","text":"evaluate(c::Coloring, config)\n\nCompute the energy of the vertex coloring configuration config, the energy is the number of violated edges.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.evaluate-Tuple{ProblemReductions.MaxCut, Any}","page":"Reference","title":"ProblemReductions.evaluate","text":"evaluate(c::MaxCut, config)\n\nCompute the cut weights for the vertex configuration config (an iterator). The energy is the  sum of the weights of the edges that are cut.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.extract_solution","page":"Reference","title":"ProblemReductions.extract_solution","text":"extract_solution(reduction::AbstractReductionResult, solution)\n\nExtract the solution solution of the target problem to the original problem.\n\nArguments\n\nreduction: The reduction result.\nsolution: The solution of the target problem.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.findbest","page":"Reference","title":"ProblemReductions.findbest","text":"findbest(problem::AbstractProblem, method) -> Vector\n\nFind the best configurations of the problem using the method.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.flavors-Tuple{GT} where GT<:AbstractProblem","page":"Reference","title":"ProblemReductions.flavors","text":"flavors(::Type{<:AbstractProblem}) -> Vector\n\nReturns a vector of integers as the flavors (domain) of a degree of freedom.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.is_set_covering-Tuple{ProblemReductions.SetCovering, Any}","page":"Reference","title":"ProblemReductions.is_set_covering","text":"is_set_covering(sets::AbstractVector, config)\n\nReturn true if config (a vector of boolean numbers as the mask of sets) is a set covering of sets.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.is_vertex_coloring-Tuple{SimpleGraph, Any}","page":"Reference","title":"ProblemReductions.is_vertex_coloring","text":"is_vertex_coloring(graph::SimpleGraph, config)\n\nReturns true if the coloring specified by config is a valid one, i.e. does not violate the contraints of vertices of an edges having different colors.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.num_flavors-Tuple{GT} where GT<:AbstractProblem","page":"Reference","title":"ProblemReductions.num_flavors","text":"num_flavors(::Type{<:AbstractProblem}) -> Int\n\nReturns the number of flavors (domain) of a degree of freedom.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.num_terms-Tuple{AbstractProblem}","page":"Reference","title":"ProblemReductions.num_terms","text":"num_terms(problem::AbstractProblem) -> Int\n\nThe number of terms in the computational problem.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.num_variables-Tuple{AbstractProblem}","page":"Reference","title":"ProblemReductions.num_variables","text":"num_variables(problem::AbstractProblem) -> Int\n\nThe number of variables in the computational problem.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.onehotv-Union{Tuple{C}, Tuple{S}, Tuple{N}, Tuple{Type{StaticElementVector{N, S, C}}, Any, Any}} where {N, S, C}","page":"Reference","title":"ProblemReductions.onehotv","text":"onehotv(::Type{<:StaticElementVector}, i, v)\nonehotv(::Type{<:StaticBitVector, i)\n\nReturns a static element vector, with the value at location i being v (1 if not specified).\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.parameter_type-Tuple{AbstractProblem}","page":"Reference","title":"ProblemReductions.parameter_type","text":"parameter_type(problem::AbstractProblem) -> Type\n\nThe data type of the parameters in the computational problem.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.parameters","page":"Reference","title":"ProblemReductions.parameters","text":"parameters(problem::AbstractProblem) -> Vector\n\nParameters associated with terms.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.reduceto","page":"Reference","title":"ProblemReductions.reduceto","text":"reduceto(::Type{TA}, x::AbstractProblem)\n\nReduce the problem x to a target problem of type TA. Returns an instance of AbstractReductionResult.\n\nArguments\n\nTA: The target problem type.\nx: The original problem.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.reduction_complexity","page":"Reference","title":"ProblemReductions.reduction_complexity","text":"reduction_complexity(::Type{TA}, x::AbstractProblem) -> Int\n\nThe complexity of the reduction from the original problem to the target problem.\n\nArguments\n\nTA: The target problem type.\nx: The original problem.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.satisfiable-Union{Tuple{T}, Tuple{CNF{T}, AbstractDict{T}}} where T","page":"Reference","title":"ProblemReductions.satisfiable","text":"satisfiable(cnf::CNF, config::AbstractDict)\n\nReturns true if an assignment of variables satisfies a CNF.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.set_parameters","page":"Reference","title":"ProblemReductions.set_parameters","text":"set_parameters(problem::AbstractProblem, parameters) -> AbstractProblem\n\nChange the parameters for the problem and return a new problem instance.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.spinglass_energy-Tuple{AbstractVector{Vector{Int64}}, Any}","page":"Reference","title":"ProblemReductions.spinglass_energy","text":"spinglass_energy(g::SimpleGraph, config; J, h)\nspinglass_energy(cliques::AbstractVector{Vector{Int}}, config; weights)\n\nCompute the spin glass state energy for the vertex configuration config. In the configuration, the spin ↑ is mapped to configuration 0, while spin ↓ is mapped to configuration 1. Let G=(VE) be the input graph, the hamiltonian is\n\nH = sum_ij in E J_ij s_i s_j + sum_i in V h_i s_i\n\nwhere s_i in -1 1 stands for spin ↓ and spin ↑.\n\nIn the hypergraph case, the hamiltonian is\n\nH = sum_c in C w_c prod_i in c s_i\n\nwhere C is the set of cliques, and w_c is the weight of the clique c.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.spinglass_gadget-Tuple{Val{:arraymul}}","page":"Reference","title":"ProblemReductions.spinglass_gadget","text":"spinglass_gadget(::Val{:arraymul})\n\nThe array multiplier gadget.\n\n    s_{i+1,j-1}  p_i\n           \\     |\n        q_j ------------ q_j\n                 |\n    c_{i,j} ------------ c_{i-1,j}\n                 |     \\\n                 p_i     s_{i,j} \n\nvariables: pi, qj, pq, c{i-1,j}, s{i+1,j-1}, c{i,j}, s{i,j}\nconstraints: 2 * c{i,j} + s{i,j} = pi qj + c{i-1,j} + s{i+1,j-1}\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.target_problem","page":"Reference","title":"ProblemReductions.target_problem","text":"target_problem(res::AbstractReductionResult) -> AbstractProblem\n\nReturn the target problem of the reduction result.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.terms","page":"Reference","title":"ProblemReductions.terms","text":"terms(problem::AbstractProblem) -> Vector\n\nThe energy terms of a computational problem is defined as the variables that carrying local energies (or weights) in the computational problem.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.truth_table-Tuple{LogicGadget}","page":"Reference","title":"ProblemReductions.truth_table","text":"truth_table(ga::LogicGadget; variables=1:num_variables(ga.problem), solver=BruteForce())\n\nCompute the truth table of a logic gadget.\n\nArguments\n\nga::LogicGadget: the logic gadget.\n\nKeyword Arguments\n\nvariables::Vector{Int}: the variables to be displayed.\nsolver::AbstractSolver: the solver to be used.\n\n\n\n\n\n","category":"method"},{"location":"ref/#ProblemReductions.variables","page":"Reference","title":"ProblemReductions.variables","text":"variables(problem::AbstractProblem) -> Vector\n\nThe degrees of freedoms in the computational problem. e.g. for the maximum independent set problems, they are the indices of vertices: 1, 2, 3..., while for the max cut problem, they are the edges.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.@bools-Tuple{Vararg{Symbol}}","page":"Reference","title":"ProblemReductions.@bools","text":"@bools(syms::Symbol...)\n\nCreate some boolean variables of type BoolVar in current scope that can be used in create a CNF.\n\nExample\n\nUnder Development\n\n\n\n\n\n","category":"macro"},{"location":"ref/#ProblemReductions.@bv_str-Tuple{Any}","page":"Reference","title":"ProblemReductions.@bv_str","text":"Constructing a static bit vector.\n\n\n\n\n\n","category":"macro"},{"location":"ref/#ProblemReductions.@circuit-Tuple{Any}","page":"Reference","title":"ProblemReductions.@circuit","text":"@circuit circuit_expr\n\nConstruct a circuit expression from a block of assignments.\n\nExamples\n\njulia> @circuit begin\n        x = a ∨ b\n        y = x ∧ c\n       end\nCircuit:\n| x = ∨(a, b)\n| y = ∧(x, c)\n\n\n\n\n\n","category":"macro"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = ProblemReductions","category":"page"},{"location":"#ProblemReductions","page":"Home","title":"ProblemReductions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for ProblemReductions.","category":"page"},{"location":"rules/#Problem-Reduction-Rules","page":"Problem Reduction Rules","title":"Problem Reduction Rules","text":"","category":"section"},{"location":"rules/","page":"Problem Reduction Rules","title":"Problem Reduction Rules","text":"A problem reduction rule is a function that reduces a problem to another problem. By solving the target problem, we can extract the solution to the original problem. The reduction rule is defined as a function that takes an instance of the original problem and returns an AbstractReductionResult instance of the target problem.","category":"page"},{"location":"rules/#Interfaces","page":"Problem Reduction Rules","title":"Interfaces","text":"","category":"section"},{"location":"rules/","page":"Problem Reduction Rules","title":"Problem Reduction Rules","text":"reduceto: Reduce the source problem to a target problem of a specific type. Returns an AbstractReductionResult instance, which contains the target problem.\ntarget_problem: Return the target problem of the reduction result.\nextract_solution: Extract the solution of the target problem to the original problem.","category":"page"},{"location":"rules/","page":"Problem Reduction Rules","title":"Problem Reduction Rules","text":"Optional functions include:","category":"page"},{"location":"rules/","page":"Problem Reduction Rules","title":"Problem Reduction Rules","text":"reduction_complexity: The computational complexity of the reduction rule.","category":"page"},{"location":"models/CircuitSAT/#Circuit-Satisfaction","page":"Circuit Satisfaction","title":"Circuit Satisfaction","text":"","category":"section"},{"location":"models/CircuitSAT/#Problem-Definition","page":"Circuit Satisfaction","title":"Problem Definition","text":"","category":"section"},{"location":"models/CircuitSAT/","page":"Circuit Satisfaction","title":"Circuit Satisfaction","text":"A circuit can be defined with the @circuit macro as follows:","category":"page"},{"location":"models/CircuitSAT/","page":"Circuit Satisfaction","title":"Circuit Satisfaction","text":"using ProblemReductions\n\ncircuit = @circuit begin\n    c = x ∧ y\n    d = x ∨ (c ∧ ¬z)\nend","category":"page"},{"location":"models/CircuitSAT/","page":"Circuit Satisfaction","title":"Circuit Satisfaction","text":"The circuit can be converted to a CircuitSAT problem instance:","category":"page"},{"location":"models/CircuitSAT/","page":"Circuit Satisfaction","title":"Circuit Satisfaction","text":"sat = CircuitSAT(circuit)\nsat.symbols","category":"page"},{"location":"models/CircuitSAT/","page":"Circuit Satisfaction","title":"Circuit Satisfaction","text":"Note that the circuit is converted to the static single assignment (SSA) form, and the symbols are stored in the symbols field. The symbols are variables in the circuit to be assigned to true or false.","category":"page"},{"location":"models/CircuitSAT/#Interfaces","page":"Circuit Satisfaction","title":"Interfaces","text":"","category":"section"},{"location":"models/CircuitSAT/","page":"Circuit Satisfaction","title":"Circuit Satisfaction","text":"variables(sat)\nflavors(sat)","category":"page"},{"location":"models/CircuitSAT/","page":"Circuit Satisfaction","title":"Circuit Satisfaction","text":"The circuit can be evaluated with the evaluate function:","category":"page"},{"location":"models/CircuitSAT/","page":"Circuit Satisfaction","title":"Circuit Satisfaction","text":"evaluate(sat, [true, false, true, true, false, false, true])","category":"page"},{"location":"models/CircuitSAT/","page":"Circuit Satisfaction","title":"Circuit Satisfaction","text":"The return value is 0 if the assignment satisfies the circuit, otherwise, it is the number of unsatisfied clauses.","category":"page"},{"location":"models/CircuitSAT/","page":"Circuit Satisfaction","title":"Circuit Satisfaction","text":"note: Note\nevaluate funciton returns lower values for satisfiable assignments.","category":"page"},{"location":"models/CircuitSAT/","page":"Circuit Satisfaction","title":"Circuit Satisfaction","text":"To find all satisfying assignments, use the findbest function:","category":"page"},{"location":"models/CircuitSAT/","page":"Circuit Satisfaction","title":"Circuit Satisfaction","text":"findbest(sat, BruteForce())","category":"page"},{"location":"models/CircuitSAT/","page":"Circuit Satisfaction","title":"Circuit Satisfaction","text":"Here, the BruteForce solver is used to find the best assignment.","category":"page"}]
}
